{"version":3,"file":"groupRowsFn.js","sources":["../../../src/utils/groupRowsFn.ts"],"sourcesContent":["import { ReactTable, Row, RowModel } from '../types'\nimport { Options } from '../types'\nimport { GroupingState } from '../features/Grouping'\nimport { flattenBy } from '../utils'\n\nexport const groupRowsFn: Options<any, any, {}, {}, {}>['groupRowsFn'] = <\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  groupingState: GroupingState,\n  sortedRowModel: RowModel<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n): RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> => {\n  // Filter the grouping list down to columns that exist\n  const existingGrouping = groupingState.filter(columnId =>\n    instance.getColumn(columnId)\n  )\n\n  // Find the columns that can or are aggregating\n  // Uses each column to aggregate rows into a single value\n  const aggregateRowsToValues = (\n    leafRows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n    groupedRows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n    depth: number\n  ) => {\n    const values: Record<string, unknown> = {}\n\n    instance.getAllLeafColumns().forEach(column => {\n      // Don't aggregate columns that are in the grouping\n      if (existingGrouping.includes(column.id)) {\n        values[column.id] = groupedRows[0]\n          ? groupedRows[0].values[column.id]\n          : null\n        return\n      }\n\n      // Aggregate the values\n      const aggregateFn = instance.getColumnAggregationFn(column.id)\n\n      if (aggregateFn) {\n        // Get the columnValues to aggregate\n        const groupedValues = groupedRows.map(row => row.values[column.id])\n\n        // Get the columnValues to aggregate\n        const leafValues = leafRows.map(row => {\n          let columnValue = row.values[column.id]\n\n          if (!depth && column.aggregateValue) {\n            columnValue = column.aggregateValue(columnValue)\n          }\n\n          return columnValue\n        })\n\n        values[column.id] = aggregateFn(leafValues, groupedValues)\n      } else if (column.aggregationType) {\n        console.info({ column })\n        throw new Error(\n          process.env.NODE_ENV !== 'production'\n            ? `React Table: Invalid column.aggregateType option for column listed above`\n            : ''\n        )\n      } else {\n        values[column.id] = null\n      }\n    })\n\n    return values\n  }\n\n  const groupedFlatRows: Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[] = []\n  const groupedRowsById: Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  > = {}\n  // const onlyGroupedFlatRows: Row[] = [];\n  // const onlyGroupedRowsById: Record<RowId, Row> = {};\n  // const nonGroupedFlatRows: Row[] = [];\n  // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n  // Recursively group the data\n  const groupUpRecursively = (\n    rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n    depth = 0,\n    parentId: string\n  ) => {\n    // This is the last level, just return the rows\n    if (depth === existingGrouping.length) {\n      return rows\n    }\n\n    const columnId = existingGrouping[depth]!\n\n    // Group the rows together for this level\n    const rowGroupsMap = groupBy(rows, columnId)\n\n    // Peform aggregations for each group\n    const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map(\n      ([groupingValue, groupedRows], index) => {\n        let id = `${columnId}:${groupingValue}`\n        id = parentId ? `${parentId}>${id}` : id\n\n        // First, Recurse to group sub rows before aggregation\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id)\n\n        // Flatten the leaf rows of the rows in this group\n        const leafRows = depth\n          ? flattenBy(groupedRows, row => row.leafRows)\n          : groupedRows\n\n        const values = aggregateRowsToValues(leafRows, groupedRows, depth)\n\n        const row = instance.createRow(id, undefined, index, depth, values)\n\n        Object.assign(row, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n        })\n\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow)\n          groupedRowsById[subRow.id] = subRow\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        })\n\n        return row\n      }\n    )\n\n    return aggregatedGroupedRows\n  }\n\n  const groupedRows = groupUpRecursively(sortedRowModel.rows, 0, '')\n\n  groupedRows.forEach(subRow => {\n    groupedFlatRows.push(subRow)\n    groupedRowsById[subRow.id] = subRow\n    // if (subRow.getIsGrouped?.()) {\n    //   onlyGroupedFlatRows.push(subRow);\n    //   onlyGroupedRowsById[subRow.id] = subRow;\n    // } else {\n    //   nonGroupedFlatRows.push(subRow);\n    //   nonGroupedRowsById[subRow.id] = subRow;\n    // }\n  })\n\n  return {\n    rows: groupedRows,\n    flatRows: groupedFlatRows,\n    rowsById: groupedRowsById,\n  }\n}\n\nfunction groupBy<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnId: string\n) {\n  const groupMap = new Map<\n    any,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  >()\n\n  return rows.reduce((map, row) => {\n    const resKey = `${row.values[columnId]}`\n    const previous = map.get(resKey)\n    if (!previous) {\n      map.set(resKey, [row])\n    } else {\n      map.set(resKey, [...previous, row])\n    }\n    return map\n  }, groupMap)\n}\n"],"names":["groupRowsFn","instance","groupingState","sortedRowModel","existingGrouping","filter","columnId","getColumn","aggregateRowsToValues","leafRows","groupedRows","depth","values","getAllLeafColumns","forEach","column","includes","id","aggregateFn","getColumnAggregationFn","groupedValues","map","row","leafValues","columnValue","aggregateValue","aggregationType","console","info","Error","process","env","NODE_ENV","groupedFlatRows","groupedRowsById","groupUpRecursively","rows","parentId","length","rowGroupsMap","groupBy","aggregatedGroupedRows","Array","from","entries","index","groupingValue","subRows","flattenBy","createRow","undefined","Object","assign","groupingColumnId","subRow","push","flatRows","rowsById","groupMap","Map","reduce","resKey","previous","get","set"],"mappings":"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"}