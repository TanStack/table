{"version":3,"file":"columnFilterRowsFn.js","sources":["../../../src/utils/columnFilterRowsFn.ts"],"sourcesContent":["import { ReactTable, Row, RowModel } from '../types'\nimport { ColumnFiltersState } from '../features/Filters'\nimport { Options } from '..'\n\nexport const columnFilterRowsFn: Options<\n  any,\n  any,\n  {},\n  {},\n  {}\n>['columnFilterRowsFn'] = <\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  columnFilters: ColumnFiltersState,\n  rowModel: RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> => {\n  const newFilteredFlatRows: Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[] = []\n  const newFilteredRowsById: Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  > = {}\n\n  const filterFromChildrenUp = instance.options.filterFromChildrenUp\n\n  const filterRows = (\n    rowsToFilter: Row<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[],\n    depth: number\n  ) => {\n    columnFilters.forEach(({ id: columnId, value: filterValue }) => {\n      // Find the columnFilters column\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `React-Table: Could not find a column with id: ${columnId}`\n          )\n        }\n        throw new Error()\n      }\n\n      if (depth === 0) {\n        const preFilteredRows = [...rowsToFilter]\n        column.getPreFilteredRows = () => preFilteredRows\n      }\n\n      const filterFn = instance.getColumnFilterFn(column.id)\n\n      if (!filterFn) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Could not find a valid 'column.filterType' for column with the ID: ${column.id}.`\n          )\n        }\n        return\n      }\n\n      // Pass the rows, id, filterValue and column to the filterFn\n      // to get the filtered rows back\n      rowsToFilter = filterFn(rowsToFilter, [columnId], filterValue)\n    })\n\n    return rowsToFilter\n  }\n\n  if (filterFromChildrenUp) {\n    const recurseFilterRows = (\n      rowsToFilter: Row<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      >[],\n      depth = 0\n    ) => {\n      // Filter from children up\n      rowsToFilter = rowsToFilter.filter(row => {\n        if (!row.subRows?.length) {\n          return true\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n\n        return row.subRows.length\n      })\n\n      rowsToFilter = filterRows(rowsToFilter, depth)\n\n      // Apply the filter to any subRows\n      rowsToFilter.forEach(row => {\n        newFilteredFlatRows.push(row)\n        newFilteredRowsById[row.id] = row\n      })\n\n      return rowsToFilter\n    }\n\n    return {\n      rows: recurseFilterRows(rowModel.rows),\n      flatRows: newFilteredFlatRows,\n      rowsById: newFilteredRowsById,\n    }\n  }\n\n  // Filters top level and nested rows\n  const recurseFilterRows = (\n    rowsToFilter: Row<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[],\n    depth = 0\n  ) => {\n    // Filter from parents downward\n    rowsToFilter = filterRows(rowsToFilter, depth)\n\n    // Apply the filter to any subRows\n    // We technically could do this recursively in the above loop,\n    // but that would severely hinder the API for the user, since they\n    // would be required to do that recursion in some scenarios\n    rowsToFilter.forEach(row => {\n      newFilteredFlatRows.push(row)\n      newFilteredRowsById[row.id] = row\n\n      if (!filterFromChildrenUp) {\n        if (!row.subRows?.length) {\n          return\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n      }\n    })\n\n    return rowsToFilter\n  }\n\n  return {\n    rows: recurseFilterRows(rowModel.rows),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n"],"names":["columnFilterRowsFn","instance","columnFilters","rowModel","newFilteredFlatRows","newFilteredRowsById","filterFromChildrenUp","options","filterRows","rowsToFilter","depth","forEach","columnId","id","filterValue","value","column","getColumn","process","env","NODE_ENV","console","warn","Error","preFilteredRows","getPreFilteredRows","filterFn","getColumnFilterFn","recurseFilterRows","filter","row","subRows","length","push","rows","flatRows","rowsById"],"mappings":"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"}