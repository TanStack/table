{"version":3,"file":"globalFilterRowsFn.js","sources":["../../../src/utils/globalFilterRowsFn.ts"],"sourcesContent":["import { Options } from '..'\nimport { ReactTable, Row, RowModel } from '../types'\n\nexport const globalFilterRowsFn: Options<\n  any,\n  any,\n  {},\n  {},\n  {}\n>['globalFilterRowsFn'] = <\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  globalFilter: any,\n  rowModel: RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> => {\n  const newFilteredFlatRows: Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[] = []\n  const newFilteredRowsById: Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  > = {}\n\n  const filterFromChildrenUp = instance.options.filterFromChildrenUp\n\n  const filterFn = instance.getGlobalFilterFn()\n\n  if (!filterFn) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`Could not find a valid 'globalFilterType'`)\n    }\n    return rowModel\n  }\n\n  const filterableColumns = instance\n    .getAllLeafColumns()\n    .filter(column => column.getCanGlobalFilter())\n\n  const filterableColumnIds = filterableColumns.map(d => d.id)\n\n  if (filterFromChildrenUp) {\n    const recurseFilterRows = (\n      rowsToFilter: Row<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      >[],\n      depth = 0\n    ) => {\n      // Filter from children up\n      rowsToFilter = rowsToFilter.filter(row => {\n        if (!row.subRows?.length) {\n          return true\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n\n        return row.subRows.length\n      })\n\n      rowsToFilter = filterFn(rowsToFilter, filterableColumnIds, globalFilter)\n\n      // Apply the filter to any subRows\n      rowsToFilter.forEach(row => {\n        newFilteredFlatRows.push(row)\n        newFilteredRowsById[row.id] = row\n      })\n\n      return rowsToFilter\n    }\n\n    return {\n      rows: recurseFilterRows(rowModel.rows),\n      flatRows: newFilteredFlatRows,\n      rowsById: newFilteredRowsById,\n    }\n  }\n\n  // Filters top level and nested rows\n  const recurseFilterRows = (\n    rowsToFilter: Row<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[],\n    depth = 0\n  ) => {\n    // Filter from parents downward\n    rowsToFilter = filterFn(rowsToFilter, filterableColumnIds, globalFilter)\n\n    // Apply the filter to any subRows\n    // We technically could do this recursively in the above loop,\n    // but that would severely hinder the API for the user, since they\n    // would be required to do that recursion in some scenarios\n    rowsToFilter.forEach(row => {\n      newFilteredFlatRows.push(row)\n      newFilteredRowsById[row.id] = row\n\n      if (!filterFromChildrenUp) {\n        if (!row.subRows?.length) {\n          return\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n      }\n    })\n\n    return rowsToFilter\n  }\n\n  return {\n    rows: recurseFilterRows(rowModel.rows),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n"],"names":["globalFilterRowsFn","instance","globalFilter","rowModel","newFilteredFlatRows","newFilteredRowsById","filterFromChildrenUp","options","filterFn","getGlobalFilterFn","process","env","NODE_ENV","console","warn","filterableColumns","getAllLeafColumns","filter","column","getCanGlobalFilter","filterableColumnIds","map","d","id","recurseFilterRows","rowsToFilter","depth","row","subRows","length","forEach","push","rows","flatRows","rowsById"],"mappings":";;;;;;;;;;;;;;IAGaA,kBAMU,GAAG,SANbA,kBAMa,CAOxBC,QAPwB,EAQxBC,YARwB,EASxBC,QATwB,EAU8C;AACtE,MAAMC,mBAMH,GAAG,EANN;AAOA,MAAMC,mBAGL,GAAG,EAHJ;AAKA,MAAMC,oBAAoB,GAAGL,QAAQ,CAACM,OAAT,CAAiBD,oBAA9C;AAEA,MAAME,QAAQ,GAAGP,QAAQ,CAACQ,iBAAT,EAAjB;;AAEA,MAAI,CAACD,QAAL,EAAe;AACb,QAAIE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCC,MAAAA,OAAO,CAACC,IAAR;AACD;;AACD,WAAOX,QAAP;AACD;;AAED,MAAMY,iBAAiB,GAAGd,QAAQ,CAC/Be,iBADuB,GAEvBC,MAFuB,CAEhB,UAAAC,MAAM;AAAA,WAAIA,MAAM,CAACC,kBAAP,EAAJ;AAAA,GAFU,CAA1B;AAIA,MAAMC,mBAAmB,GAAGL,iBAAiB,CAACM,GAAlB,CAAsB,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAACC,EAAN;AAAA,GAAvB,CAA5B;;AAEA,MAAIjB,oBAAJ,EAA0B;AACxB,QAAMkB,kBAAiB,GAAG,SAApBA,kBAAoB,CACxBC,YADwB,EAQxBC,KARwB,EASrB;;AACH;AACAD,MAAAA,YAAY,GAAGA,YAAY,CAACR,MAAb,CAAoB,UAAAU,GAAG,EAAI;AAAA;;AACxC,YAAI,kBAACA,GAAG,CAACC,OAAL,aAAC,aAAaC,MAAd,CAAJ,EAA0B;AACxB,iBAAO,IAAP;AACD;;AAEDF,QAAAA,GAAG,CAACC,OAAJ,GAAcJ,kBAAiB,CAACG,GAAG,CAACC,OAAL,CAA/B;AAEA,eAAOD,GAAG,CAACC,OAAJ,CAAYC,MAAnB;AACD,OARc,CAAf;AAUAJ,MAAAA,YAAY,GAAGjB,QAAQ,CAACiB,YAAD,EAAeL,mBAAf,EAAoClB,YAApC,CAAvB,CAZG;;AAeHuB,MAAAA,YAAY,CAACK,OAAb,CAAqB,UAAAH,GAAG,EAAI;AAC1BvB,QAAAA,mBAAmB,CAAC2B,IAApB,CAAyBJ,GAAzB;AACAtB,QAAAA,mBAAmB,CAACsB,GAAG,CAACJ,EAAL,CAAnB,GAA8BI,GAA9B;AACD,OAHD;AAKA,aAAOF,YAAP;AACD,KA9BD;;AAgCA,WAAO;AACLO,MAAAA,IAAI,EAAER,kBAAiB,CAACrB,QAAQ,CAAC6B,IAAV,CADlB;AAELC,MAAAA,QAAQ,EAAE7B,mBAFL;AAGL8B,MAAAA,QAAQ,EAAE7B;AAHL,KAAP;AAKD,GApEqE;;;AAuEtE,MAAMmB,iBAAiB,GAAG,SAApBA,iBAAoB,CACxBC,YADwB,EAQxBC,KARwB,EASrB;;AACH;AACAD,IAAAA,YAAY,GAAGjB,QAAQ,CAACiB,YAAD,EAAeL,mBAAf,EAAoClB,YAApC,CAAvB,CAFG;AAKH;AACA;AACA;;AACAuB,IAAAA,YAAY,CAACK,OAAb,CAAqB,UAAAH,GAAG,EAAI;AAC1BvB,MAAAA,mBAAmB,CAAC2B,IAApB,CAAyBJ,GAAzB;AACAtB,MAAAA,mBAAmB,CAACsB,GAAG,CAACJ,EAAL,CAAnB,GAA8BI,GAA9B;;AAEA,UAAI,CAACrB,oBAAL,EAA2B;AAAA;;AACzB,YAAI,mBAACqB,GAAG,CAACC,OAAL,aAAC,cAAaC,MAAd,CAAJ,EAA0B;AACxB;AACD;;AAEDF,QAAAA,GAAG,CAACC,OAAJ,GAAcJ,iBAAiB,CAACG,GAAG,CAACC,OAAL,CAA/B;AACD;AACF,KAXD;AAaA,WAAOH,YAAP;AACD,GA/BD;;AAiCA,SAAO;AACLO,IAAAA,IAAI,EAAER,iBAAiB,CAACrB,QAAQ,CAAC6B,IAAV,CADlB;AAELC,IAAAA,QAAQ,EAAE7B,mBAFL;AAGL8B,IAAAA,QAAQ,EAAE7B;AAHL,GAAP;AAKD;;;;"}