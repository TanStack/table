{"version":3,"file":"sortRowsFn.js","sources":["../../../src/utils/sortRowsFn.ts"],"sourcesContent":["import { ReactTable, Row, RowModel } from '../types'\nimport { SortingFn, SortingState } from '../features/Sorting'\nimport { Options } from '../types'\n\nexport const sortRowsFn: Options<any, any, {}, {}, {}>['sortRowsFn'] = <\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  sortingState: SortingState,\n  rowModel: RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> => {\n  const sortedFlatRows: Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[] = []\n\n  // Filter out sortings that correspond to non existing columns\n  const availableSorting = sortingState.filter(sort =>\n    instance.getColumnCanSort(sort.id)\n  )\n\n  const columnInfoById: Record<\n    string,\n    {\n      sortUndefined?: false | -1 | 1\n      invertSorting?: boolean\n      sortingFn: SortingFn<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      >\n    }\n  > = {}\n\n  availableSorting.forEach(sortEntry => {\n    const column = instance.getColumn(sortEntry.id)!\n\n    columnInfoById[sortEntry.id] = {\n      sortUndefined: column.sortUndefined,\n      invertSorting: column.invertSorting,\n      sortingFn: instance.getColumnSortingFn(sortEntry.id)!,\n    }\n  })\n\n  const sortData = (\n    rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  ) => {\n    // This will also perform a stable sorting using the row index\n    // if needed.\n    const sortedData = rows.slice()\n\n    sortedData.sort((rowA, rowB) => {\n      for (let i = 0; i < availableSorting.length; i += 1) {\n        const sortEntry = availableSorting[i]!\n        const columnInfo = columnInfoById[sortEntry.id]!\n        const isDesc = sortEntry?.desc ?? false\n\n        if (columnInfo.sortUndefined) {\n          const aValue = rowA.values[sortEntry.id]\n          const bValue = rowB.values[sortEntry.id]\n\n          const aUndefined = typeof aValue === 'undefined'\n          const bUndefined = typeof bValue === 'undefined'\n\n          if (aUndefined || bUndefined) {\n            return aUndefined && bUndefined ? 0 : aUndefined ? 1 : -1\n          }\n        }\n\n        // This function should always return in ascending order\n        let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id)\n\n        if (sortInt !== 0) {\n          if (isDesc) {\n            sortInt *= -1\n          }\n\n          if (columnInfo.invertSorting) {\n            sortInt *= -1\n          }\n\n          return sortInt\n        }\n      }\n\n      return rowA.index - rowB.index\n    })\n\n    // If there are sub-rows, sort them\n    sortedData.forEach(row => {\n      sortedFlatRows.push(row)\n      if (!row.subRows || row.subRows.length <= 1) {\n        return\n      }\n      row.subRows = sortData(row.subRows)\n    })\n\n    return sortedData\n  }\n\n  return {\n    rows: sortData(rowModel.rows),\n    flatRows: sortedFlatRows,\n    rowsById: rowModel.rowsById,\n  }\n}\n"],"names":["sortRowsFn","instance","sortingState","rowModel","sortedFlatRows","availableSorting","filter","sort","getColumnCanSort","id","columnInfoById","forEach","sortEntry","column","getColumn","sortUndefined","invertSorting","sortingFn","getColumnSortingFn","sortData","rows","sortedData","slice","rowA","rowB","i","length","columnInfo","isDesc","desc","aValue","values","bValue","aUndefined","bUndefined","sortInt","index","row","push","subRows","flatRows","rowsById"],"mappings":"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"}