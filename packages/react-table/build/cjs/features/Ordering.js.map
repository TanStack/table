{"version":3,"file":"Ordering.js","sources":["../../../src/features/Ordering.ts"],"sourcesContent":["import { functionalUpdate, makeStateUpdater, memo } from '../utils'\n\nimport { ReactTable, OnChangeFn, Updater, Column } from '../types'\n\nimport * as Grouping from './Grouping'\n\nexport type ColumnOrderState = string[]\n\nexport type ColumnOrderTableState = {\n  columnOrder: string[]\n}\n\nexport type ColumnOrderOptions = {\n  onColumnOrderChange?: OnChangeFn<ColumnOrderState>\n}\n\nexport type ColumnOrderDefaultOptions = {\n  onColumnOrderChange: OnChangeFn<ColumnOrderState>\n}\n\nexport type ColumnOrderInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  setColumnOrder: (updater: Updater<ColumnOrderState>) => void\n  resetColumnOrder: () => void\n  getOrderColumnsFn: () => (\n    columns: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  ) => Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n}\n\n//\n\nexport function getInitialState(): ColumnOrderTableState {\n  return {\n    columnOrder: [],\n  }\n}\n\nexport function getDefaultOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): ColumnOrderDefaultOptions {\n  return {\n    onColumnOrderChange: makeStateUpdater('columnOrder', instance),\n  }\n}\n\nexport function getInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): ColumnOrderInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> {\n  return {\n    setColumnOrder: updater =>\n      instance.options.onColumnOrderChange?.(\n        updater,\n        functionalUpdate(updater, instance.getState().columnOrder)\n      ),\n    resetColumnOrder: () => {\n      instance.setColumnOrder(instance.initialState.columnOrder ?? [])\n    },\n    getOrderColumnsFn: memo(\n      () => [\n        instance.getState().columnOrder,\n        instance.getState().grouping,\n        instance.options.groupedColumnMode,\n      ],\n      (columnOrder, grouping, groupedColumnMode) => columns => {\n        // Sort grouped columns to the start of the column list\n        // before the headers are built\n        let orderedColumns: Column<\n          TData,\n          TValue,\n          TFilterFns,\n          TSortingFns,\n          TAggregationFns\n        >[] = []\n\n        // If there is no order, return the normal columns\n        if (!columnOrder?.length) {\n          orderedColumns = columns\n        } else {\n          const columnOrderCopy = [...columnOrder]\n\n          // If there is an order, make a copy of the columns\n          const columnsCopy = [...columns]\n\n          // And make a new ordered array of the columns\n\n          // Loop over the columns and place them in order into the new array\n          while (columnsCopy.length && columnOrderCopy.length) {\n            const targetColumnId = columnOrderCopy.shift()\n            const foundIndex = columnsCopy.findIndex(\n              d => d.id === targetColumnId\n            )\n            if (foundIndex > -1) {\n              orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]!)\n            }\n          }\n\n          // If there are any columns left, add them to the end\n          orderedColumns = [...orderedColumns, ...columnsCopy]\n        }\n\n        return Grouping.orderColumns(\n          orderedColumns,\n          grouping,\n          groupedColumnMode\n        )\n      },\n      'getOrderColumnsFn',\n      instance.options.debug\n    ),\n  }\n}\n"],"names":["getInitialState","columnOrder","getDefaultOptions","instance","onColumnOrderChange","makeStateUpdater","getInstance","setColumnOrder","updater","options","functionalUpdate","getState","resetColumnOrder","initialState","getOrderColumnsFn","memo","grouping","groupedColumnMode","columns","orderedColumns","length","columnOrderCopy","columnsCopy","targetColumnId","shift","foundIndex","findIndex","d","id","push","splice","Grouping","debug"],"mappings":";;;;;;;;;;;;;;;;;AAkCA;AAEO,SAASA,eAAT,GAAkD;AACvD,SAAO;AACLC,IAAAA,WAAW,EAAE;AADR,GAAP;AAGD;AAEM,SAASC,iBAAT,CAOLC,QAPK,EAQsB;AAC3B,SAAO;AACLC,IAAAA,mBAAmB,EAAEC,sBAAgB,CAAC,aAAD,EAAgBF,QAAhB;AADhC,GAAP;AAGD;AAEM,SAASG,WAAT,CAOLH,QAPK,EAcL;AACA,SAAO;AACLI,IAAAA,cAAc,EAAE,wBAAAC,OAAO;AAAA,aACrBL,QAAQ,CAACM,OAAT,CAAiBL,mBADI,oBACrBD,QAAQ,CAACM,OAAT,CAAiBL,mBAAjB,CACEI,OADF,EAEEE,sBAAgB,CAACF,OAAD,EAAUL,QAAQ,CAACQ,QAAT,GAAoBV,WAA9B,CAFlB,CADqB;AAAA,KADlB;AAMLW,IAAAA,gBAAgB,EAAE,4BAAM;AAAA;;AACtBT,MAAAA,QAAQ,CAACI,cAAT,0BAAwBJ,QAAQ,CAACU,YAAT,CAAsBZ,WAA9C,oCAA6D,EAA7D;AACD,KARI;AASLa,IAAAA,iBAAiB,EAAEC,UAAI,CACrB;AAAA,aAAM,CACJZ,QAAQ,CAACQ,QAAT,GAAoBV,WADhB,EAEJE,QAAQ,CAACQ,QAAT,GAAoBK,QAFhB,EAGJb,QAAQ,CAACM,OAAT,CAAiBQ,iBAHb,CAAN;AAAA,KADqB,EAMrB,UAAChB,WAAD,EAAce,QAAd,EAAwBC,iBAAxB;AAAA,aAA8C,UAAAC,OAAO,EAAI;AACvD;AACA;AACA,YAAIC,cAMD,GAAG,EANN,CAHuD;;AAYvD,YAAI,EAAClB,WAAD,YAACA,WAAW,CAAEmB,MAAd,CAAJ,EAA0B;AACxBD,UAAAA,cAAc,GAAGD,OAAjB;AACD,SAFD,MAEO;AACL,cAAMG,eAAe,aAAOpB,WAAP,CAArB,CADK;;AAIL,cAAMqB,WAAW,aAAOJ,OAAP,CAAjB,CAJK;AAQL;;AARK;AAUH,gBAAMK,cAAc,GAAGF,eAAe,CAACG,KAAhB,EAAvB;AACA,gBAAMC,UAAU,GAAGH,WAAW,CAACI,SAAZ,CACjB,UAAAC,CAAC;AAAA,qBAAIA,CAAC,CAACC,EAAF,KAASL,cAAb;AAAA,aADgB,CAAnB;;AAGA,gBAAIE,UAAU,GAAG,CAAC,CAAlB,EAAqB;AACnBN,cAAAA,cAAc,CAACU,IAAf,CAAoBP,WAAW,CAACQ,MAAZ,CAAmBL,UAAnB,EAA+B,CAA/B,EAAkC,CAAlC,CAApB;AACD;AAhBE;;AASL,iBAAOH,WAAW,CAACF,MAAZ,IAAsBC,eAAe,CAACD,MAA7C,EAAqD;AAAA;AAQpD,WAjBI;;;AAoBLD,UAAAA,cAAc,aAAOA,cAAP,EAA0BG,WAA1B,CAAd;AACD;;AAED,eAAOS,qBAAA,CACLZ,cADK,EAELH,QAFK,EAGLC,iBAHK,CAAP;AAKD,OA1CD;AAAA,KANqB,EAiDrB,mBAjDqB,EAkDrBd,QAAQ,CAACM,OAAT,CAAiBuB,KAlDI;AATlB,GAAP;AA8DD;;;;;;"}