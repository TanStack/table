{"version":3,"file":"index.production.js","sources":["../../src/utils.tsx","../../src/aggregationTypes.ts","../../src/features/Ordering.ts","../../src/features/Grouping.ts","../../src/features/Headers.ts","../../src/filterTypes.ts","../../src/features/Filters.ts","../../src/sortTypes.ts","../../src/features/Expanding.ts","../../src/core.tsx","../../src/features/Visibility.ts","../../src/features/Pinning.ts","../../src/features/Sorting.ts","../../src/utils/columnFilterRowsFn.ts","../../src/createTable.tsx","../../src/utils/expandRowsFn.ts","../../src/utils/globalFilterRowsFn.ts","../../src/utils/groupRowsFn.ts","../../src/utils/sortRowsFn.ts"],"sourcesContent":["import React from 'react'\nimport { Getter, NoInfer, PropGetterValue, Renderable } from './types'\n\nexport type IsAny<T> = 0 extends 1 & T ? true : false\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\nexport type RequiredKeys<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type Overwrite<T, U> = Omit<T, keyof U> & U\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\nexport function functionalUpdate<TInput, TOutput = TInput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nexport function noop() {\n  //\n}\n\nexport function makeStateUpdater(key: string, instance: unknown) {\n  return (updater: Updater<any, any>) => {\n    ;(instance as any).setState(<TTableState,>(old: TTableState) => {\n      return {\n        ...old,\n        [key]: functionalUpdate(updater, (old as any)[key]),\n      }\n    })\n  }\n}\n\n// SSR has issues with useLayoutEffect still, so use useEffect during SSR\nexport const safeUseLayoutEffect =\n  typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nexport function useMountedLayoutEffect(fn: any, deps: any[]) {\n  const mountedRef = React.useRef(false)\n\n  safeUseLayoutEffect(() => {\n    if (mountedRef.current) {\n      fn()\n    }\n    mountedRef.current = true\n    // eslint-disable-next-line\n  }, deps)\n}\n\nexport function useGetLatest<T>(obj: T): () => T {\n  const ref = React.useRef<T>()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current!, [])\n}\n\ntype AnyFunction = (...args: any) => any\n\nexport function isFunction<T extends AnyFunction>(d: any): d is T {\n  return d instanceof Function\n}\n\nexport function flattenBy<TNode>(\n  arr: TNode[],\n  getChildren: (item: TNode) => TNode[]\n) {\n  const flat: TNode[] = []\n\n  const recurse = (subArr: TNode[]) => {\n    subArr.forEach(item => {\n      flat.push(item)\n      const children = getChildren(item)\n      if (children?.length) {\n        recurse(children)\n      }\n    })\n  }\n\n  recurse(arr)\n\n  return flat\n}\n\ntype PropGetterImpl = <TBaseProps, TGetter extends Getter<TBaseProps>>(\n  initial: TBaseProps,\n  userProps?: TGetter\n) => PropGetterValue<TBaseProps, TGetter>\n\n// @ts-ignore // Just rely on the type, not the implementation\nexport const propGetter: PropGetterImpl = (initial, getter) => {\n  if (isFunction(getter)) {\n    return getter(initial)\n  }\n\n  return {\n    ...initial,\n    ...(getter ?? {}),\n  }\n}\n\nexport function memo<TDeps extends readonly any[], TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  key?: string,\n  debug?: boolean\n): () => TResult {\n  let deps: any[] = []\n  let result: TResult | undefined\n\n  return () => {\n    const newDeps = getDeps()\n    const newSerializedDeps = newDeps\n    const oldSerializedDeps = deps\n\n    const depsChanged =\n      newSerializedDeps.length !== oldSerializedDeps.length ||\n      newSerializedDeps.some(\n        (dep: any, index: number) => oldSerializedDeps[index] !== dep\n      )\n\n    if (depsChanged) {\n      if (debug) {\n        console.info(key, {\n          length: `${oldSerializedDeps.length} -> ${newSerializedDeps.length}`,\n          ...newSerializedDeps\n            .map((_, index) => {\n              if (oldSerializedDeps[index] !== newSerializedDeps[index]) {\n                return [\n                  index,\n                  oldSerializedDeps[index],\n                  newSerializedDeps[index],\n                ]\n              }\n\n              return false\n            })\n            .filter(Boolean)\n            .reduce(\n              (accu, curr: any) => ({\n                ...accu,\n                [curr[0]]: curr.slice(1),\n              }),\n              {}\n            ),\n          parent,\n        })\n      }\n      result = fn(...newDeps)\n      deps = newSerializedDeps\n    }\n\n    return result!\n  }\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport type Render = typeof flexRender\n\nexport function flexRender<TProps extends {}>(\n  Comp: Renderable<TProps>,\n  props: TProps\n): React.ReactNode {\n  return !Comp ? null : isReactComponent(Comp) ? <Comp {...props} /> : Comp\n}\n\nfunction isReactComponent(component: unknown): component is React.FC {\n  return (\n    isClassComponent(component) ||\n    typeof component === 'function' ||\n    isExoticComponent(component)\n  )\n}\n\nfunction isClassComponent(component: any) {\n  return (\n    typeof component === 'function' &&\n    (() => {\n      const proto = Object.getPrototypeOf(component)\n      return proto.prototype && proto.prototype.isReactComponent\n    })()\n  )\n}\n\nfunction isExoticComponent(component: any) {\n  return (\n    typeof component === 'object' &&\n    typeof component.$$typeof === 'symbol' &&\n    ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description)\n  )\n}\n\n// export function hashString(str: string, seed = 0): string {\n//   let h1 = 0xdeadbeef ^ seed,\n//     h2 = 0x41c6ce57 ^ seed\n//   for (let i = 0, ch; i < str.length; i++) {\n//     ch = str.charCodeAt(i)\n//     h1 = Math.imul(h1 ^ ch, 2654435761)\n//     h2 = Math.imul(h2 ^ ch, 1597334677)\n//   }\n//   h1 =\n//     Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^\n//     Math.imul(h2 ^ (h2 >>> 13), 3266489909)\n//   h2 =\n//     Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^\n//     Math.imul(h1 ^ (h1 >>> 13), 3266489909)\n//   return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString()\n// }\n","export const aggregationTypes = {\n  sum,\n  min,\n  max,\n  extent,\n  mean,\n  median,\n  unique,\n  uniqueCount,\n  count,\n}\n\nexport type BuiltInAggregationType = keyof typeof aggregationTypes\n\nfunction sum(_leafValues: unknown[], childValues: unknown[]) {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return childValues.reduce(\n    (sum: number, next: unknown) => sum + (typeof next === 'number' ? next : 0),\n    0\n  )\n}\n\nfunction min(_leafValues: unknown[], childValues: unknown[]) {\n  let min: number | undefined\n\n  for (const value of childValues as number[]) {\n    if (\n      value != null &&\n      (min! > value || (min === undefined && value >= value))\n    ) {\n      min = value\n    }\n  }\n\n  return min\n}\n\nfunction max(_leafValues: unknown[], childValues: unknown[]) {\n  let max: number | undefined\n\n  for (const value of childValues as number[]) {\n    if (\n      value != null &&\n      (max! < value || (max === undefined && value >= value))\n    ) {\n      max = value\n    }\n  }\n\n  return max\n}\n\nfunction extent(_leafValues: unknown[], childValues: unknown[]) {\n  let min: number | undefined\n  let max: number | undefined\n\n  for (const value of childValues as number[]) {\n    if (value != null) {\n      if (min === undefined) {\n        if (value >= value) min = max = value\n      } else {\n        if (min > value) min = value\n        if (max! < value) max = value\n      }\n    }\n  }\n\n  return [min, max]\n}\n\nfunction mean(leafValues: unknown[]) {\n  let count = 0\n  let sum = 0\n\n  for (let value of leafValues as number[]) {\n    if (value != null && (value = +value) >= value) {\n      ++count, (sum += value)\n    }\n  }\n\n  if (count) return sum / count\n\n  return\n}\n\nfunction median(values: unknown[]) {\n  if (!values.length) {\n    return\n  }\n\n  let min = 0\n  let max = 0\n\n  values.forEach(value => {\n    if (typeof value === 'number') {\n      min = Math.min(min, value)\n      max = Math.max(max, value)\n    }\n  })\n\n  return (min + max) / 2\n}\n\nfunction unique<T>(values: T[]) {\n  return Array.from(new Set(values).values())\n}\n\nfunction uniqueCount(values: unknown[]) {\n  return new Set(values).size\n}\n\nfunction count(values: unknown[]) {\n  return values.length\n}\n","import { functionalUpdate, makeStateUpdater, memo } from '../utils'\n\nimport { ReactTable, OnChangeFn, Updater, Column } from '../types'\n\nimport * as Grouping from './Grouping'\n\nexport type ColumnOrderState = string[]\n\nexport type ColumnOrderTableState = {\n  columnOrder: string[]\n}\n\nexport type ColumnOrderOptions = {\n  onColumnOrderChange?: OnChangeFn<ColumnOrderState>\n}\n\nexport type ColumnOrderDefaultOptions = {\n  onColumnOrderChange: OnChangeFn<ColumnOrderState>\n}\n\nexport type ColumnOrderInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  setColumnOrder: (updater: Updater<ColumnOrderState>) => void\n  resetColumnOrder: () => void\n  getOrderColumnsFn: () => (\n    columns: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  ) => Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n}\n\n//\n\nexport function getInitialState(): ColumnOrderTableState {\n  return {\n    columnOrder: [],\n  }\n}\n\nexport function getDefaultOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): ColumnOrderDefaultOptions {\n  return {\n    onColumnOrderChange: makeStateUpdater('columnOrder', instance),\n  }\n}\n\nexport function getInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): ColumnOrderInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> {\n  return {\n    setColumnOrder: updater =>\n      instance.options.onColumnOrderChange?.(\n        updater,\n        functionalUpdate(updater, instance.getState().columnOrder)\n      ),\n    resetColumnOrder: () => {\n      instance.setColumnOrder(instance.initialState.columnOrder ?? [])\n    },\n    getOrderColumnsFn: memo(\n      () => [\n        instance.getState().columnOrder,\n        instance.getState().grouping,\n        instance.options.groupedColumnMode,\n      ],\n      (columnOrder, grouping, groupedColumnMode) => columns => {\n        // Sort grouped columns to the start of the column list\n        // before the headers are built\n        let orderedColumns: Column<\n          TData,\n          TValue,\n          TFilterFns,\n          TSortingFns,\n          TAggregationFns\n        >[] = []\n\n        // If there is no order, return the normal columns\n        if (!columnOrder?.length) {\n          orderedColumns = columns\n        } else {\n          const columnOrderCopy = [...columnOrder]\n\n          // If there is an order, make a copy of the columns\n          const columnsCopy = [...columns]\n\n          // And make a new ordered array of the columns\n\n          // Loop over the columns and place them in order into the new array\n          while (columnsCopy.length && columnOrderCopy.length) {\n            const targetColumnId = columnOrderCopy.shift()\n            const foundIndex = columnsCopy.findIndex(\n              d => d.id === targetColumnId\n            )\n            if (foundIndex > -1) {\n              orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]!)\n            }\n          }\n\n          // If there are any columns left, add them to the end\n          orderedColumns = [...orderedColumns, ...columnsCopy]\n        }\n\n        return Grouping.orderColumns(\n          orderedColumns,\n          grouping,\n          groupedColumnMode\n        )\n      },\n      'getOrderColumnsFn',\n      instance.options.debug\n    ),\n  }\n}\n","import React, { MouseEvent, TouchEvent } from 'react'\nimport { RowModel } from '..'\nimport { BuiltInAggregationType, aggregationTypes } from '../aggregationTypes'\nimport {\n  Cell,\n  Column,\n  Getter,\n  OnChangeFn,\n  PropGetterValue,\n  ReactTable,\n  Row,\n  Updater,\n} from '../types'\nimport {\n  functionalUpdate,\n  isFunction,\n  makeStateUpdater,\n  memo,\n  propGetter,\n} from '../utils'\n\nexport type GroupingState = string[]\n\nexport type AggregationFn = (leafValues: any[], childValues: any[]) => any\n\nexport type AggregationType<TAggregationFns> =\n  | 'auto'\n  | BuiltInAggregationType\n  | keyof TAggregationFns\n  | AggregationFn\n\nexport type GroupingTableState = {\n  grouping: GroupingState\n}\n\nexport type GroupingColumnDef<TAggregationFns> = {\n  aggregationType?: AggregationType<TAggregationFns>\n  aggregateValue?: (columnValue: unknown) => any\n  renderAggregatedCell?: () => React.ReactNode\n  enableGrouping?: boolean\n  defaultCanGroup?: boolean\n  getCanGroup?: unknown\n}\n\nexport type GroupingColumn<\n  _TData,\n  _TValue,\n  _TFilterFns,\n  _TSortingFns,\n  TAggregationFns\n> = {\n  aggregationType?: AggregationType<TAggregationFns>\n  getCanGroup: () => boolean\n  getIsGrouped: () => boolean\n  getGroupedIndex: () => number\n  toggleGrouping: () => void\n  getToggleGroupingProps: <TGetter extends Getter<ToggleGroupingProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleGroupingProps, TGetter>\n}\n\nexport type GroupingRow = {\n  groupingColumnId?: string\n  groupingValue?: any\n  getIsGrouped: () => boolean\n}\n\nexport type GroupingCell = {\n  getIsGrouped: () => boolean\n  getIsPlaceholder: () => boolean\n  getIsAggregated: () => boolean\n}\n\nexport type ColumnDefaultOptions = {\n  // Column\n  onGroupingChange: OnChangeFn<GroupingState>\n  autoResetGrouping: boolean\n  enableGrouping: boolean\n}\n\nexport type GroupingOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  aggregationTypes?: TAggregationFns\n  onGroupingChange?: OnChangeFn<GroupingState>\n  autoResetGrouping?: boolean\n  enableGrouping?: boolean\n  enableGroupingRemoval?: boolean\n  groupRowsFn?: (\n    instance: ReactTable<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >,\n    groupingState: GroupingState,\n    sortedRowsModel: RowModel<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >\n  ) => RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n\n  groupedColumnMode?: false | 'reorder' | 'remove'\n}\n\nexport type GroupingColumnMode = false | 'reorder' | 'remove'\n\nexport type ToggleGroupingProps = {\n  title?: string\n  onClick?: (event: MouseEvent | TouchEvent) => void\n}\n\nexport type GroupingInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  getColumnAutoAggregationFn: (columnId: string) => AggregationFn | undefined\n  getColumnAggregationFn: (columnId: string) => AggregationFn | undefined\n  setGrouping: (updater: Updater<GroupingState>) => void\n  resetGrouping: () => void\n  toggleColumnGrouping: (columnId: string) => void\n  getColumnCanGroup: (columnId: string) => boolean\n  getColumnIsGrouped: (columnId: string) => boolean\n  getColumnGroupedIndex: (columnId: string) => number\n  getToggleGroupingProps: <TGetter extends Getter<ToggleGroupingProps>>(\n    columnId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleGroupingProps, TGetter>\n  getRowIsGrouped: (rowId: string) => boolean\n  getGroupedRowModel: () => RowModel<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n  getPreGroupedRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getPreGroupedFlatRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getPreGroupedRowsById: () => Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n  getGroupedRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getGroupedFlatRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getGroupedRowsById: () => Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n}\n\n//\n\nexport function getDefaultColumn<TFilterFns>(): GroupingColumnDef<TFilterFns> {\n  return {\n    aggregationType: 'auto',\n  }\n}\n\nexport function getInitialState(): GroupingTableState {\n  return {\n    grouping: [],\n  }\n}\n\nexport function getDefaultOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): GroupingOptions<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    onGroupingChange: makeStateUpdater('grouping', instance),\n    autoResetGrouping: true,\n    groupedColumnMode: 'reorder',\n  }\n}\n\nexport function createColumn<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): GroupingColumn<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    aggregationType: column.aggregationType,\n    getCanGroup: () => instance.getColumnCanGroup(column.id),\n    getGroupedIndex: () => instance.getColumnGroupedIndex(column.id),\n    getIsGrouped: () => instance.getColumnIsGrouped(column.id),\n    toggleGrouping: () => instance.toggleColumnGrouping(column.id),\n    getToggleGroupingProps: userProps =>\n      instance.getToggleGroupingProps(column.id, userProps),\n  }\n}\n\nexport function getInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): GroupingInstance<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    getColumnAutoAggregationFn: columnId => {\n      const firstRow = instance.getCoreFlatRows()[0]\n\n      const value = firstRow?.values[columnId]\n\n      if (typeof value === 'number') {\n        return aggregationTypes.sum\n      }\n\n      if (Object.prototype.toString.call(value) === '[object Date]') {\n        return aggregationTypes.extent\n      }\n\n      return aggregationTypes.count\n    },\n    getColumnAggregationFn: columnId => {\n      const column = instance.getColumn(columnId)\n      const userAggregationTypes = instance.options.aggregationTypes\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return isFunction(column.aggregationType)\n        ? column.aggregationType\n        : column.aggregationType === 'auto'\n        ? instance.getColumnAutoFilterFn(columnId)\n        : (userAggregationTypes as Record<string, any>)?.[\n            column.aggregationType as string\n          ] ??\n          (aggregationTypes[\n            column.aggregationType as BuiltInAggregationType\n          ] as AggregationFn)\n    },\n\n    setGrouping: updater =>\n      instance.options.onGroupingChange?.(\n        updater,\n        functionalUpdate(updater, instance.getState().grouping)\n      ),\n\n    toggleColumnGrouping: columnId => {\n      instance.setGrouping(old => {\n        // Find any existing grouping for this column\n        if (old?.includes(columnId)) {\n          return old.filter(d => d !== columnId)\n        }\n\n        return [...(old ?? []), columnId]\n      })\n    },\n\n    getColumnCanGroup: columnId => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return (\n        column.enableGrouping ??\n        instance.options.enableGrouping ??\n        column.defaultCanGroup ??\n        !!column.accessorFn\n      )\n    },\n\n    getColumnIsGrouped: columnId => {\n      return instance.getState().grouping?.includes(columnId)\n    },\n\n    getColumnGroupedIndex: columnId =>\n      instance.getState().grouping?.indexOf(columnId),\n\n    resetGrouping: () => {\n      instance.setGrouping(instance.options?.initialState?.grouping ?? [])\n    },\n\n    getToggleGroupingProps: (columnId, userProps) => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        return\n      }\n\n      const canGroup = column.getCanGroup()\n\n      const initialProps: ToggleGroupingProps = {\n        title: canGroup ? 'Toggle Grouping' : undefined,\n        onClick: canGroup\n          ? (e: MouseEvent | TouchEvent) => {\n              e.persist()\n              column.toggleGrouping?.()\n            }\n          : undefined,\n      }\n\n      return propGetter(initialProps, userProps)\n    },\n\n    getRowIsGrouped: rowId => !!instance.getRow(rowId)?.groupingColumnId,\n\n    getGroupedRowModel: memo(\n      () => [\n        instance.getState().grouping,\n        instance.getSortedRowModel(),\n        instance.options.groupRowsFn,\n      ],\n      (grouping, rowModel, groupRowsFn) => {\n        if (!groupRowsFn || !grouping.length) {\n          return rowModel\n        }\n\n        if (process.env.NODE_ENV !== 'production' && instance.options.debug)\n          console.info('Grouping...')\n\n        return groupRowsFn(instance, grouping, rowModel)\n      },\n      'getGroupedRowModel',\n      instance.options.debug\n    ),\n\n    getPreGroupedRows: () => instance.getSortedRowModel().rows,\n    getPreGroupedFlatRows: () => instance.getSortedRowModel().flatRows,\n    getPreGroupedRowsById: () => instance.getSortedRowModel().rowsById,\n    getGroupedRows: () => instance.getGroupedRowModel().rows,\n    getGroupedFlatRows: () => instance.getGroupedRowModel().flatRows,\n    getGroupedRowsById: () => instance.getGroupedRowModel().rowsById,\n  }\n}\n\nexport function createRow<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  row: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): GroupingRow {\n  return {\n    getIsGrouped: () => instance.getRowIsGrouped(row.id),\n  }\n}\n\nexport function createCell<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  cell: Cell<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> &\n    GroupingCell,\n  column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  row: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  _instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): GroupingCell {\n  return {\n    getIsGrouped: () =>\n      column.getIsGrouped() && column.id === row.groupingColumnId,\n    getIsPlaceholder: () => !cell.getIsGrouped() && column.getIsGrouped(),\n    getIsAggregated: () =>\n      !cell.getIsGrouped() &&\n      !cell.getIsPlaceholder() &&\n      row.subRows?.length > 1,\n  }\n}\n\nexport function orderColumns<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  leafColumns: Column<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[],\n  grouping: string[],\n  groupedColumnMode?: GroupingColumnMode\n) {\n  if (!grouping?.length || !groupedColumnMode) {\n    return leafColumns\n  }\n\n  const nonGroupingColumns = leafColumns.filter(\n    col => !grouping.includes(col.id)\n  )\n\n  if (groupedColumnMode === 'remove') {\n    return nonGroupingColumns\n  }\n\n  const groupingColumns = grouping\n    .map(g => leafColumns.find(col => col.id === g)!)\n    .filter(Boolean)\n\n  return [...groupingColumns, ...nonGroupingColumns]\n}\n","import {\n  Cell,\n  Column,\n  FooterGroupProps,\n  FooterProps,\n  Getter,\n  Header,\n  HeaderGroup,\n  HeaderGroupProps,\n  HeaderProps,\n  PropGetterValue,\n  ReactTable,\n  Row,\n} from '../types'\nimport { propGetter, memo, flexRender } from '../utils'\n\nexport type HeadersRow<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  _getAllVisibleCells: () => Cell<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getVisibleCells: () => Cell<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getLeftVisibleCells: () => Cell<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getCenterVisibleCells: () => Cell<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getRightVisibleCells: () => Cell<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n}\n\nexport type HeadersInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  createHeader: (\n    column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n    options: {\n      id?: string\n      isPlaceholder?: boolean\n      placeholderId?: string\n      depth: number\n    }\n  ) => Header<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  getHeaderGroups: () => HeaderGroup<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getLeftHeaderGroups: () => HeaderGroup<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getCenterHeaderGroups: () => HeaderGroup<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getRightHeaderGroups: () => HeaderGroup<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n\n  getFooterGroups: () => HeaderGroup<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getCenterFooterGroups: () => HeaderGroup<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getLeftFooterGroups: () => HeaderGroup<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getRightFooterGroups: () => HeaderGroup<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n\n  getFlatHeaders: () => Header<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getLeftFlatHeaders: () => Header<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getCenterFlatHeaders: () => Header<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getRightFlatHeaders: () => Header<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n\n  getLeafHeaders: () => Header<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getLeftLeafHeaders: () => Header<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getCenterLeafHeaders: () => Header<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getRightLeafHeaders: () => Header<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n\n  getHeader: (\n    id: string\n  ) => Header<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n\n  getHeaderGroupProps: <TGetter extends Getter<HeaderGroupProps>>(\n    id: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<HeaderGroupProps, TGetter>\n  getFooterGroupProps: <TGetter extends Getter<FooterGroupProps>>(\n    id: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<FooterGroupProps, TGetter>\n  getHeaderProps: <TGetter extends Getter<HeaderProps>>(\n    headerId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<HeaderProps, TGetter>\n  getFooterProps: <TGetter extends Getter<FooterProps>>(\n    headerId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<FooterProps, TGetter>\n  getTotalWidth: () => number\n}\n\n//\n\nexport function createRow<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  row: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): HeadersRow<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    _getAllVisibleCells: memo(\n      () => [\n        row\n          .getAllCells()\n          .filter(cell => cell.column.getIsVisible())\n          .map(d => d.id)\n          .join('_'),\n      ],\n      _ => {\n        return row.getAllCells().filter(cell => cell.column.getIsVisible())\n      },\n      'row._getAllVisibleCells',\n      instance.options.debug\n    ),\n    getVisibleCells: memo(\n      () => [\n        row.getLeftVisibleCells(),\n        row.getCenterVisibleCells(),\n        row.getRightVisibleCells(),\n      ],\n      (left, center, right) => [...left, ...center, ...right],\n      'row.getVisibleCells',\n      instance.options.debug\n    ),\n    getCenterVisibleCells: memo(\n      () => [\n        row._getAllVisibleCells(),\n        instance.getState().columnPinning.left,\n        instance.getState().columnPinning.right,\n      ],\n      (allCells, left, right) => {\n        const leftAndRight = [...(left ?? []), ...(right ?? [])]\n\n        return allCells.filter(d => !leftAndRight.includes(d.columnId))\n      },\n      'row.getCenterVisibleCells',\n      instance.options.debug\n    ),\n    getLeftVisibleCells: memo(\n      () => [\n        row._getAllVisibleCells(),\n        instance.getState().columnPinning.left,\n        ,\n      ],\n      (allCells, left) => {\n        const cells = (left ?? [])\n          .map(columnId => allCells.find(cell => cell.columnId === columnId)!)\n          .filter(Boolean)\n\n        return cells\n      },\n      'row.getLeftVisibleCells',\n      instance.options.debug\n    ),\n    getRightVisibleCells: memo(\n      () => [\n        row._getAllVisibleCells(),\n        instance.getState().columnPinning.right,\n      ],\n      (allCells, right) => {\n        const cells = (right ?? [])\n          .map(columnId => allCells.find(cell => cell.columnId === columnId)!)\n          .filter(Boolean)\n\n        return cells\n      },\n      'row.getRightVisibleCells',\n      instance.options.debug\n    ),\n  }\n}\n\nexport function getInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): HeadersInstance<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    createHeader: (\n      column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n      options: {\n        id?: string\n        isPlaceholder?: boolean\n        placeholderId?: string\n        depth: number\n      }\n    ) => {\n      const id = options.id ?? column.id\n\n      let header: Header<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      > = {\n        id,\n        column,\n        isPlaceholder: options.isPlaceholder,\n        placeholderId: options.placeholderId,\n        depth: options.depth,\n        subHeaders: [],\n        colSpan: 0,\n        rowSpan: 0,\n        getWidth: () => {\n          let sum = 0\n\n          const recurse = (\n            header: Header<\n              TData,\n              TValue,\n              TFilterFns,\n              TSortingFns,\n              TAggregationFns\n            >\n          ) => {\n            if (header.subHeaders.length) {\n              header.subHeaders.forEach(recurse)\n            } else {\n              sum += header.column.getWidth() ?? 0\n            }\n          }\n\n          recurse(header)\n\n          return sum\n        },\n        getLeafHeaders: (): Header<\n          TData,\n          TValue,\n          TFilterFns,\n          TSortingFns,\n          TAggregationFns\n        >[] => {\n          const leafHeaders: Header<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >[] = []\n\n          const recurseHeader = (\n            h: Header<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n          ) => {\n            if (h.subHeaders && h.subHeaders.length) {\n              h.subHeaders.map(recurseHeader)\n            }\n            leafHeaders.push(h)\n          }\n\n          recurseHeader(header)\n          return leafHeaders\n        },\n        getHeaderProps: userProps =>\n          instance.getHeaderProps(header.id, userProps)!,\n        getFooterProps: userProps =>\n          instance.getFooterProps(header.id, userProps)!,\n        renderHeader: () => flexRender(column.header, { header, column }),\n        renderFooter: () => flexRender(column.footer, { header, column }),\n      }\n\n      return header\n    },\n\n    // Header Groups\n\n    getHeaderGroups: memo(\n      () => [\n        instance.getAllColumns(),\n        instance.getVisibleLeafColumns(),\n        instance.getState().columnPinning.left,\n        instance.getState().columnPinning.right,\n      ],\n      (allColumns, leafColumns, left, right) => {\n        const leftColumns = leafColumns.filter(column =>\n          left?.includes(column.id)\n        )\n        const rightColumns = leafColumns.filter(column =>\n          right?.includes(column.id)\n        )\n        const centerColumns = leafColumns.filter(\n          column => !left?.includes(column.id) && !right?.includes(column.id)\n        )\n        const headerGroups = buildHeaderGroups(\n          allColumns,\n          [...leftColumns, ...centerColumns, ...rightColumns],\n          instance\n        )\n\n        return headerGroups\n      },\n      'getHeaderGroups',\n      instance.options.debug\n    ),\n\n    getCenterHeaderGroups: memo(\n      () => [\n        instance.getAllColumns(),\n        instance.getVisibleLeafColumns(),\n        instance.getState().columnPinning.left,\n        instance.getState().columnPinning.right,\n      ],\n      (allColumns, leafColumns, left, right) => {\n        leafColumns = leafColumns.filter(\n          column => !left?.includes(column.id) && !right?.includes(column.id)\n        )\n        return buildHeaderGroups(allColumns, leafColumns, instance, 'center')\n      },\n      'getCenterHeaderGroups',\n      instance.options.debug\n    ),\n\n    getLeftHeaderGroups: memo(\n      () => [\n        instance.getAllColumns(),\n        instance.getVisibleLeafColumns(),\n        instance.getState().columnPinning.left,\n      ],\n      (allColumns, leafColumns, left) => {\n        leafColumns = leafColumns.filter(column => left?.includes(column.id))\n        return buildHeaderGroups(allColumns, leafColumns, instance, 'left')\n      },\n      'getLeftHeaderGroups',\n      instance.options.debug\n    ),\n\n    getRightHeaderGroups: memo(\n      () => [\n        instance.getAllColumns(),\n        instance.getVisibleLeafColumns(),\n        instance.getState().columnPinning.right,\n      ],\n      (allColumns, leafColumns, right) => {\n        leafColumns = leafColumns.filter(column => right?.includes(column.id))\n        return buildHeaderGroups(allColumns, leafColumns, instance, 'right')\n      },\n      'getRightHeaderGroups',\n      instance.options.debug\n    ),\n\n    // Footer Groups\n\n    getFooterGroups: memo(\n      () => [instance.getHeaderGroups()],\n      headerGroups => {\n        return [...headerGroups].reverse()\n      },\n      'getFooterGroups',\n      instance.options.debug\n    ),\n\n    getLeftFooterGroups: memo(\n      () => [instance.getLeftHeaderGroups()],\n      headerGroups => {\n        return [...headerGroups].reverse()\n      },\n      'getLeftFooterGroups',\n      instance.options.debug\n    ),\n\n    getCenterFooterGroups: memo(\n      () => [instance.getCenterHeaderGroups()],\n      headerGroups => {\n        return [...headerGroups].reverse()\n      },\n      'getCenterFooterGroups',\n      instance.options.debug\n    ),\n\n    getRightFooterGroups: memo(\n      () => [instance.getRightHeaderGroups()],\n      headerGroups => {\n        return [...headerGroups].reverse()\n      },\n      'getRightFooterGroups',\n      instance.options.debug\n    ),\n\n    // Flat Headers\n\n    getFlatHeaders: memo(\n      () => [instance.getHeaderGroups()],\n      headerGroups => {\n        return headerGroups\n          .map(headerGroup => {\n            return headerGroup.headers\n          })\n          .flat()\n      },\n      'getFlatHeaders',\n      instance.options.debug\n    ),\n\n    getLeftFlatHeaders: memo(\n      () => [instance.getLeftHeaderGroups()],\n      left => {\n        return left\n          .map(headerGroup => {\n            return headerGroup.headers\n          })\n          .flat()\n      },\n      'getLeftFlatHeaders',\n      instance.options.debug\n    ),\n\n    getCenterFlatHeaders: memo(\n      () => [instance.getCenterHeaderGroups()],\n      left => {\n        return left\n          .map(headerGroup => {\n            return headerGroup.headers\n          })\n          .flat()\n      },\n      'getCenterFlatHeaders',\n      instance.options.debug\n    ),\n\n    getRightFlatHeaders: memo(\n      () => [instance.getRightHeaderGroups()],\n      left => {\n        return left\n          .map(headerGroup => {\n            return headerGroup.headers\n          })\n          .flat()\n      },\n      'getRightFlatHeaders',\n      instance.options.debug\n    ),\n\n    // Leaf Headers\n\n    getCenterLeafHeaders: memo(\n      () => [instance.getCenterFlatHeaders()],\n      flatHeaders => {\n        return flatHeaders.filter(header => !header.subHeaders?.length)\n      },\n      'getCenterLeafHeaders',\n      instance.options.debug\n    ),\n\n    getLeftLeafHeaders: memo(\n      () => [instance.getLeftFlatHeaders()],\n      flatHeaders => {\n        return flatHeaders.filter(header => !header.subHeaders?.length)\n      },\n      'getLeftLeafHeaders',\n      instance.options.debug\n    ),\n\n    getRightLeafHeaders: memo(\n      () => [instance.getRightFlatHeaders()],\n      flatHeaders => {\n        return flatHeaders.filter(header => !header.subHeaders?.length)\n      },\n      'getRightLeafHeaders',\n      instance.options.debug\n    ),\n\n    getLeafHeaders: memo(\n      () => [\n        instance.getLeftHeaderGroups(),\n        instance.getCenterHeaderGroups(),\n        instance.getRightHeaderGroups(),\n      ],\n      (left, center, right) => {\n        return [\n          ...(left[0]?.headers ?? []),\n          ...(center[0]?.headers ?? []),\n          ...(right[0]?.headers ?? []),\n        ]\n          .map(header => {\n            return header.getLeafHeaders()\n          })\n          .flat()\n      },\n      'getLeafHeaders',\n      instance.options.debug\n    ),\n\n    getHeader: (id: string) => {\n      const header = [\n        ...instance.getFlatHeaders(),\n        ...instance.getCenterFlatHeaders(),\n        ...instance.getLeftFlatHeaders(),\n        ...instance.getRightFlatHeaders(),\n      ].find(d => d.id === id)\n\n      if (!header) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`Could not find header with id: ${id}`)\n        }\n        throw new Error()\n      }\n\n      return header\n    },\n\n    getHeaderGroupProps: (id, userProps) => {\n      const headerGroup = instance.getHeaderGroups().find(d => d.id === id)\n\n      if (!headerGroup) {\n        return\n      }\n\n      return propGetter(\n        {\n          key: headerGroup.id,\n          role: 'row',\n        },\n        userProps\n      )\n    },\n\n    getFooterGroupProps: (id, userProps) => {\n      const headerGroup = instance.getFooterGroups().find(d => d.id === id)\n\n      if (!headerGroup) {\n        return\n      }\n\n      const initialProps = {\n        key: headerGroup.id,\n        role: 'row',\n      }\n\n      return propGetter(initialProps, userProps)\n    },\n\n    getHeaderProps: (id, userProps) => {\n      const header = instance.getHeader(id)\n\n      if (!header) {\n        throw new Error()\n      }\n\n      const initialProps: HeaderProps = {\n        key: header.id,\n        role: 'columnheader',\n        colSpan: header.colSpan,\n        rowSpan: header.rowSpan,\n      }\n\n      return propGetter(initialProps, userProps)\n    },\n\n    getFooterProps: (id, userProps) => {\n      const header = instance.getHeader(id)\n      if (!header) {\n        return\n      }\n\n      const initialProps: FooterProps = {\n        key: header.id,\n        role: 'columnfooter',\n        colSpan: header.colSpan,\n        rowSpan: header.rowSpan,\n      }\n\n      return propGetter(initialProps, userProps)\n    },\n\n    getTotalWidth: () => {\n      let width = 0\n\n      instance.getVisibleLeafColumns().forEach(column => {\n        width += column.getWidth() ?? 0\n      })\n\n      return width\n    },\n  }\n}\n\nexport function buildHeaderGroups<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  allColumns: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnsToGroup: Column<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[],\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  headerFamily?: 'center' | 'left' | 'right'\n) {\n  // Find the max depth of the columns:\n  // build the leaf column row\n  // build each buffer row going up\n  //    placeholder for non-existent level\n  //    real column for existing level\n\n  let maxDepth = 0\n\n  const findMaxDepth = (\n    columns: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n    depth = 1\n  ) => {\n    maxDepth = Math.max(maxDepth, depth)\n\n    columns\n      .filter(column => column.getIsVisible())\n      .forEach(column => {\n        if (column.columns?.length) {\n          findMaxDepth(column.columns, depth + 1)\n        }\n      }, 0)\n  }\n\n  findMaxDepth(allColumns)\n\n  let headerGroups: HeaderGroup<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[] = []\n\n  const createHeaderGroup = (\n    headersToGroup: Header<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[],\n    depth: number\n  ) => {\n    // The header group we are creating\n    const headerGroup: HeaderGroup<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    > = {\n      depth,\n      id: [headerFamily, `${depth}`].filter(Boolean).join('_'),\n      headers: [],\n      getHeaderGroupProps: getterValue =>\n        instance.getHeaderGroupProps(`${depth}`, getterValue)!,\n      getFooterGroupProps: getterValue =>\n        instance.getFooterGroupProps(`${depth}`, getterValue)!,\n    }\n\n    // The parent columns we're going to scan next\n    const parentHeaders: Header<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[] = []\n\n    // Scan each column for parents\n    headersToGroup.forEach(headerToGroup => {\n      // What is the latest (last) parent column?\n\n      const latestParentHeader = [...parentHeaders].reverse()[0]\n\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth\n\n      let column: Column<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      >\n      let isPlaceholder = false\n\n      if (isLeafHeader && headerToGroup.column.parent) {\n        // The parent header is new\n        column = headerToGroup.column.parent\n      } else {\n        // The parent header is repeated\n        column = headerToGroup.column\n        isPlaceholder = true\n      }\n\n      const header = instance.createHeader(column, {\n        id: [headerFamily, depth, column.id, headerToGroup?.id]\n          .filter(Boolean)\n          .join('_'),\n        isPlaceholder,\n        placeholderId: isPlaceholder\n          ? `${parentHeaders.filter(d => d.column === column).length}`\n          : undefined,\n        depth,\n      })\n\n      if (!latestParentHeader || latestParentHeader.column !== header.column) {\n        header.subHeaders.push(headerToGroup)\n        parentHeaders.push(header)\n      } else {\n        latestParentHeader.subHeaders.push(headerToGroup)\n      }\n\n      // if (!headerToGroup.isPlaceholder) {\n      //   headerToGroup.column.header = headerToGroup;\n      // }\n\n      headerGroup.headers.push(headerToGroup)\n    })\n\n    headerGroups.push(headerGroup)\n\n    if (depth > 0) {\n      createHeaderGroup(parentHeaders, depth - 1)\n    }\n  }\n\n  const bottomHeaders = columnsToGroup.map(column =>\n    instance.createHeader(column, {\n      depth: maxDepth,\n    })\n  )\n\n  createHeaderGroup(bottomHeaders, maxDepth - 1)\n\n  headerGroups.reverse()\n\n  // headerGroups = headerGroups.filter(headerGroup => {\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\n  // })\n\n  const recurseHeadersForSpans = (\n    headers: Header<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  ) => {\n    const filteredHeaders = headers.filter(header =>\n      header.column.getIsVisible()\n    )\n\n    return filteredHeaders.map(header => {\n      let colSpan = 0\n      let rowSpan = 0\n      let childRowSpans = [0]\n\n      if (header.subHeaders && header.subHeaders.length) {\n        childRowSpans = []\n\n        recurseHeadersForSpans(header.subHeaders).forEach(\n          ({ colSpan: childColSpan, rowSpan: childRowSpan }) => {\n            colSpan += childColSpan\n            childRowSpans.push(childRowSpan)\n          }\n        )\n      } else {\n        colSpan = 1\n      }\n\n      const minChildRowSpan = Math.min(...childRowSpans)\n      rowSpan = rowSpan + minChildRowSpan\n\n      header.colSpan = colSpan > 0 ? colSpan : undefined\n      header.rowSpan = rowSpan > 0 ? rowSpan : undefined\n\n      return { colSpan, rowSpan }\n    })\n  }\n\n  recurseHeadersForSpans(headerGroups[0]?.headers ?? [])\n\n  return headerGroups\n}\n","import { AccessorFn, Row } from './types'\n\nexport const filterTypes = {\n  includesString,\n  includesStringSensitive,\n  equalsString,\n  equalsStringSensitive,\n  arrIncludes,\n  arrIncludesAll,\n  equals,\n  weakEquals,\n  betweenNumberRange,\n}\n\nexport type BuiltInFilterType = keyof typeof filterTypes\n\nfunction includesString<\n  TData,\n  TValue,\n  TAccessor extends AccessorFn<TData>,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue).toLowerCase()\n\n  rows = rows.filter(row => {\n    return columnIds.some(id => {\n      return String(row.values[id]).toLowerCase().includes(search)\n    })\n  })\n  return rows\n}\n\nincludesString.autoRemove = (val: any) => testFalsey(val)\n\nfunction includesStringSensitive<\n  TData,\n  TValue,\n  TAccessor extends AccessorFn<TData>,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue)\n\n  rows = rows.filter(row => {\n    return columnIds.some(id => {\n      return String(row.values[id]).includes(search)\n    })\n  })\n  return rows\n}\n\nincludesStringSensitive.autoRemove = (val: any) => testFalsey(val)\n\nfunction equalsString<\n  TData,\n  TValue,\n  TAccessor extends AccessorFn<TData>,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue).toLowerCase()\n\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue !== undefined\n        ? String(rowValue).toLowerCase() === search\n        : true\n    })\n  })\n}\n\nequalsString.autoRemove = (val: any) => testFalsey(val)\n\nfunction equalsStringSensitive<\n  TData,\n  TValue,\n  TAccessor extends AccessorFn<TData>,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  const search = String(filterValue)\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue !== undefined ? String(rowValue) === search : true\n    })\n  })\n}\n\nequalsStringSensitive.autoRemove = (val: any) => testFalsey(val)\n\nfunction arrIncludes<\n  TData,\n  TValue,\n  TAccessor extends AccessorFn<TData>,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue.includes(filterValue)\n    })\n  })\n}\n\narrIncludes.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nfunction arrIncludesAll<\n  TData,\n  TValue,\n  TAccessor extends AccessorFn<TData>,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnIds: string[],\n  filterValue: unknown[]\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return (\n        rowValue &&\n        rowValue.length &&\n        filterValue.every(val => rowValue.includes(val))\n      )\n    })\n  })\n}\n\narrIncludesAll.autoRemove = (val: any) => testFalsey(val) || !val?.length\n\nfunction equals<\n  TData,\n  TValue,\n  TAccessor extends AccessorFn<TData>,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue === filterValue\n    })\n  })\n}\n\nequals.autoRemove = (val: any) => testFalsey(val)\n\nfunction weakEquals<\n  TData,\n  TValue,\n  TAccessor extends AccessorFn<TData>,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnIds: string[],\n  filterValue: unknown\n) {\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      // eslint-disable-next-line eqeqeq\n      return rowValue == filterValue\n    })\n  })\n}\n\nweakEquals.autoRemove = (val: any) => testFalsey(val)\n\nfunction betweenNumberRange<\n  TData,\n  TValue,\n  TAccessor extends AccessorFn<TData>,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnIds: string[],\n  filterValue: [unknown, unknown]\n) {\n  let [unsafeMin, unsafeMax] = filterValue || []\n\n  let parsedMin =\n    typeof unsafeMin !== 'number' ? parseFloat(unsafeMin as string) : unsafeMin\n  let parsedMax =\n    typeof unsafeMax !== 'number' ? parseFloat(unsafeMax as string) : unsafeMax\n\n  let min =\n    unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax\n\n  if (min > max) {\n    const temp = min\n    min = max\n    max = temp\n  }\n\n  return rows.filter(row => {\n    return columnIds.some(id => {\n      const rowValue = row.values[id]\n      return rowValue >= min && rowValue <= max\n    })\n  })\n}\n\nbetweenNumberRange.autoRemove = (val: any) =>\n  testFalsey(val) || (testFalsey(val[0]) && testFalsey(val[1]))\n\n// Utils\n\nfunction testFalsey(val: any) {\n  return val === undefined || val === null || val === ''\n}\n","import { RowModel } from '..'\nimport { BuiltInFilterType, filterTypes } from '../filterTypes'\nimport { Column, OnChangeFn, ReactTable, Row, Updater } from '../types'\nimport { functionalUpdate, isFunction, makeStateUpdater, memo } from '../utils'\n\nexport type ColumnFilter = {\n  id: string\n  value: unknown\n}\n\nexport type ColumnFiltersState = ColumnFilter[]\n\nexport type FilterFn<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> =\n  {\n    (\n      rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n      columnIds: string[],\n      filterValue: any\n    ): any\n    autoRemove?: ColumnFilterAutoRemoveTestFn<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >\n  }\n\nexport type ColumnFilterAutoRemoveTestFn<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = (\n  value: unknown,\n  column?: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n) => boolean\n\nexport type CustomFilterTypes<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = Record<\n  string,\n  FilterFn<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n>\n\nexport type FiltersTableState = {\n  columnFilters: ColumnFiltersState\n  globalFilter: any\n}\n\nexport type FilterType<TFilterFns> =\n  | 'auto'\n  | BuiltInFilterType\n  | keyof TFilterFns\n  | FilterFn<unknown, unknown, TFilterFns, any, any>\n\nexport type FiltersColumnDef<TFilterFns> = {\n  filterType?: FilterType<TFilterFns>\n  enableAllFilters?: boolean\n  enableColumnFilter?: boolean\n  enableGlobalFilter?: boolean\n  defaultCanFilter?: boolean\n  defaultCanColumnFilter?: boolean\n  defaultCanGlobalFilter?: boolean\n}\n\nexport type FiltersColumn<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  filterType: FilterType<TFilterFns>\n  getCanColumnFilter: () => boolean\n  getCanGlobalFilter: () => boolean\n  getColumnFilterIndex: () => number\n  getIsColumnFiltered: () => boolean\n  getColumnFilterValue: () => unknown\n  setColumnFilterValue: (value: any) => void\n  getPreFilteredRows: () =>\n    | Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n    | undefined\n  getPreFilteredUniqueValues: () => Map<any, number>\n  getPreFilteredMinMaxValues: () => [any, any]\n}\n\nexport type FiltersOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  filterFromChildrenUp?: boolean\n  filterTypes?: TFilterFns\n  enableFilters?: boolean\n  // Column\n  onColumnFiltersChange?: OnChangeFn<ColumnFiltersState>\n  autoResetColumnFilters?: boolean\n  enableColumnFilters?: boolean\n  columnFilterRowsFn?: (\n    instance: ReactTable<any, any, any, any, any>,\n    columnFilters: ColumnFiltersState,\n    coreRowModel: RowModel<any, any, any, any, any>\n  ) => RowModel<any, any, any, any, any>\n  // Global\n  globalFilterType?: FilterType<TFilterFns>\n  onGlobalFilterChange?: OnChangeFn<any>\n  enableGlobalFilters?: boolean\n  autoResetGlobalFilter?: boolean\n  enableGlobalFilter?: boolean\n  globalFilterRowsFn?: (\n    instance: ReactTable<any, any, any, any, any>,\n    globalFilter: any,\n    columnFilteredRowModel: RowModel<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >\n  ) => RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  getColumnCanGlobalFilterFn?: (\n    column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  ) => boolean\n}\n\nexport type FiltersInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  getColumnAutoFilterFn: (\n    columnId: string\n  ) => FilterFn<any, any, any, any, any> | undefined\n\n  getColumnFilterFn: (\n    columnId: string\n  ) => FilterFn<any, any, any, any, any> | undefined\n\n  setColumnFilters: (updater: Updater<ColumnFiltersState>) => void\n  setColumnFilterValue: (columnId: string, value: any) => void\n  resetColumnFilters: () => void\n  getColumnCanColumnFilter: (columnId: string) => boolean\n  getColumnCanGlobalFilterFn?: (\n    column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  ) => boolean\n\n  getColumnIsFiltered: (columnId: string) => boolean\n  getColumnFilterValue: (columnId: string) => unknown\n  getColumnFilterIndex: (columnId: string) => number\n  getColumnFilteredRowModel: () => RowModel<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n  getPreColumnFilteredRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getPreColumnFilteredFlatRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getPreColumnFilteredRowsById: () => Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n  getColumnFilteredRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getColumnFilteredFlatRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getColumnFilteredRowsById: () => Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n\n  // Global\n  setGlobalFilter: (updater: Updater<any>) => void\n  resetGlobalFilter: () => void\n  getGlobalAutoFilterFn: () => FilterFn<any, any, any, any, any> | undefined\n  getGlobalFilterFn: () => FilterFn<any, any, any, any, any> | undefined\n  getColumnCanGlobalFilter: (columnId: string) => boolean\n  getGlobalFilteredRowModel: () => RowModel<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n  getPreGlobalFilteredRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getPreGlobalFilteredFlatRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getPreGlobalFilteredRowsById: () => Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n  getGlobalFilteredRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getGlobalFilteredFlatRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getGlobalFilteredRowsById: () => Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n}\n\n//\n\nexport function getDefaultColumn<TFilterFns>(): FiltersColumnDef<TFilterFns> {\n  return {\n    filterType: 'auto',\n  }\n}\n\nexport function getInitialState(): FiltersTableState {\n  return {\n    columnFilters: [],\n    globalFilter: undefined,\n  }\n}\n\nexport function getDefaultOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): FiltersOptions<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    onColumnFiltersChange: makeStateUpdater('columnFilters', instance),\n    onGlobalFilterChange: makeStateUpdater('globalFilter', instance),\n    autoResetColumnFilters: true,\n    filterFromChildrenUp: true,\n    autoResetGlobalFilter: true,\n    globalFilterType: 'auto',\n    getColumnCanGlobalFilterFn: column => {\n      const value = instance.getCoreFlatRows()[0]?.getAllCellsByColumnId()[\n        column.id\n      ]?.value\n\n      return typeof value === 'string'\n    },\n  }\n}\n\nexport function createColumn<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): FiltersColumn<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  const getFacetInfo = memo(\n    () => [column.getPreFilteredRows()],\n    (rows = []) => {\n      let preFilteredUniqueValues = new Map<any, number>()\n\n      let preFilteredMinMaxValues: [any, any] = [\n        rows[0]?.values[column.id] ?? null,\n        rows[0]?.values[column.id] ?? null,\n      ]\n\n      for (let i = 0; i < rows.length; i++) {\n        const value = rows[i]?.values[column.id]\n\n        if (preFilteredUniqueValues.has(value)) {\n          preFilteredUniqueValues.set(\n            value,\n            (preFilteredUniqueValues.get(value) ?? 0) + 1\n          )\n        } else {\n          preFilteredUniqueValues.set(value, 1)\n        }\n\n        if (value < preFilteredMinMaxValues[0]) {\n          preFilteredMinMaxValues[0] = value\n        } else if (value > preFilteredMinMaxValues[1]) {\n          preFilteredMinMaxValues[1] = value\n        }\n      }\n\n      return {\n        preFilteredUniqueValues,\n        preFilteredMinMaxValues,\n      }\n    },\n    'column.getFacetInfo',\n    instance.options.debug\n  )\n\n  return {\n    filterType: column.filterType,\n    getCanColumnFilter: () => instance.getColumnCanColumnFilter(column.id),\n    getCanGlobalFilter: () => instance.getColumnCanGlobalFilter(column.id),\n    getColumnFilterIndex: () => instance.getColumnFilterIndex(column.id),\n    getIsColumnFiltered: () => instance.getColumnIsFiltered(column.id),\n    getColumnFilterValue: () => instance.getColumnFilterValue(column.id),\n    setColumnFilterValue: val => instance.setColumnFilterValue(column.id, val),\n    getPreFilteredUniqueValues: () => getFacetInfo().preFilteredUniqueValues,\n    getPreFilteredMinMaxValues: () => getFacetInfo().preFilteredMinMaxValues,\n    getPreFilteredRows: () => undefined,\n  }\n}\n\nexport function getInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): FiltersInstance<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    getColumnAutoFilterFn: columnId => {\n      const firstRow = instance.getCoreFlatRows()[0]\n\n      const value = firstRow?.values[columnId]\n\n      if (typeof value === 'string') {\n        return filterTypes.includesString\n      }\n\n      if (typeof value === 'number') {\n        return filterTypes.betweenNumberRange\n      }\n\n      if (value !== null && typeof value === 'object') {\n        return filterTypes.equals\n      }\n\n      if (Array.isArray(value)) {\n        return filterTypes.arrIncludes\n      }\n\n      return filterTypes.weakEquals\n    },\n    getGlobalAutoFilterFn: () => {\n      return filterTypes.includesString\n    },\n    getColumnFilterFn: columnId => {\n      const column = instance.getColumn(columnId)\n      const userFilterTypes = instance.options.filterTypes\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return isFunction(column.filterType)\n        ? column.filterType\n        : column.filterType === 'auto'\n        ? instance.getColumnAutoFilterFn(columnId)\n        : (userFilterTypes as Record<string, any>)?.[\n            column.filterType as string\n          ] ??\n          (filterTypes[column.filterType as BuiltInFilterType] as FilterFn<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >)\n    },\n\n    getGlobalFilterFn: () => {\n      const { filterTypes: userFilterTypes, globalFilterType } =\n        instance.options\n\n      return isFunction(globalFilterType)\n        ? globalFilterType\n        : globalFilterType === 'auto'\n        ? instance.getGlobalAutoFilterFn()\n        : (userFilterTypes as Record<string, any>)?.[\n            globalFilterType as string\n          ] ??\n          (filterTypes[globalFilterType as BuiltInFilterType] as FilterFn<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >)\n    },\n\n    setColumnFilters: (updater: Updater<ColumnFiltersState>) => {\n      const leafColumns = instance.getAllLeafColumns()\n\n      const updateFn = (old?: ColumnFiltersState) => {\n        return functionalUpdate(updater, old)?.filter(filter => {\n          const column = leafColumns.find(d => d.id === filter.id)\n\n          if (column) {\n            const filterFn = instance.getColumnFilterFn(column.id)\n\n            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n              return false\n            }\n          }\n\n          return true\n        })\n      }\n\n      instance.options.onColumnFiltersChange?.(\n        updateFn,\n        updateFn(instance.getState().columnFilters)\n      )\n    },\n\n    setGlobalFilter: updater => {\n      instance.options.onGlobalFilterChange?.(\n        updater,\n        functionalUpdate(updater, instance.getState().globalFilter)\n      )\n    },\n\n    resetGlobalFilter: () => {\n      instance.setGlobalFilter(undefined)\n    },\n\n    getColumnCanColumnFilter: columnId => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return (\n        column.enableAllFilters ??\n        column.enableColumnFilter ??\n        instance.options.enableFilters ??\n        instance.options.enableColumnFilters ??\n        column.defaultCanFilter ??\n        column.defaultCanColumnFilter ??\n        !!column.accessorFn\n      )\n    },\n\n    getColumnCanGlobalFilter: columnId => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return (\n        ((instance.options.enableFilters ??\n          instance.options.enableGlobalFilter ??\n          column.enableAllFilters ??\n          column.enableGlobalFilter ??\n          column.defaultCanFilter ??\n          column.defaultCanGlobalFilter ??\n          !!column.accessorFn) &&\n          instance.options.getColumnCanGlobalFilterFn?.(column)) ??\n        true\n      )\n    },\n\n    getColumnIsFiltered: columnId =>\n      instance.getColumnFilterIndex(columnId) > -1,\n\n    getColumnFilterValue: columnId =>\n      instance.getState().columnFilters?.find(d => d.id === columnId)?.value,\n\n    getColumnFilterIndex: columnId =>\n      instance.getState().columnFilters?.findIndex(d => d.id === columnId) ??\n      -1,\n\n    setColumnFilterValue: (columnId, value) => {\n      if (!columnId) return\n\n      instance.setColumnFilters(old => {\n        const column = instance.getColumn(columnId)\n\n        if (!column) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `React-Table: Could not find a column with id: ${columnId}`\n            )\n          }\n          throw new Error()\n        }\n\n        const filterFn = instance.getColumnFilterFn(column.id)\n        const previousfilter = old?.find(d => d.id === columnId)\n\n        const newFilter = functionalUpdate(\n          value,\n          previousfilter ? previousfilter.value : undefined\n        )\n\n        //\n        if (\n          shouldAutoRemoveFilter(\n            filterFn as FilterFn<\n              TData,\n              TValue,\n              TFilterFns,\n              TSortingFns,\n              TAggregationFns\n            >,\n            newFilter,\n            column\n          )\n        ) {\n          return old?.filter(d => d.id !== columnId) ?? []\n        }\n\n        const newFilterObj = { id: columnId, value: newFilter }\n\n        if (previousfilter) {\n          return (\n            old?.map(d => {\n              if (d.id === columnId) {\n                return newFilterObj\n              }\n              return d\n            }) ?? []\n          )\n        }\n\n        if (old?.length) {\n          return [...old, newFilterObj]\n        }\n\n        return [newFilterObj]\n      })\n    },\n\n    resetColumnFilters: () => {\n      instance.setColumnFilters(\n        instance.options?.initialState?.columnFilters ?? []\n      )\n    },\n\n    getColumnFilteredRowModel: memo(\n      () => [\n        instance.getState().columnFilters,\n        instance.getCoreRowModel(),\n        instance.options.columnFilterRowsFn,\n      ],\n      (columnFilters, rowModel, columnFiltersFn) => {\n        const columnFilteredRowModel = (() => {\n          if (!columnFilters?.length || !columnFiltersFn) {\n            return rowModel\n          }\n\n          if (process.env.NODE_ENV !== 'production' && instance.options.debug)\n            console.info('Column Filtering...')\n\n          return columnFiltersFn(instance as any, columnFilters, rowModel)\n        })()\n\n        // Now that each filtered column has it's partially filtered rows,\n        // lets assign the final filtered rows to all of the other columns\n        const nonFilteredColumns = instance\n          .getAllLeafColumns()\n          .filter(\n            column =>\n              !instance.getState().columnFilters?.find(d => d.id === column.id)\n          )\n\n        // This essentially enables faceted filter options to be built easily\n        // using every column's preFilteredRows value\n\n        nonFilteredColumns.forEach(column => {\n          column.getPreFilteredRows = () => columnFilteredRowModel.rows\n        })\n\n        return columnFilteredRowModel\n      },\n      'getColumnFilteredRowModel',\n      instance.options.debug\n    ),\n\n    getPreColumnFilteredRows: () => instance.getCoreRowModel().rows,\n    getPreColumnFilteredFlatRows: () => instance.getCoreRowModel().flatRows,\n    getPreColumnFilteredRowsById: () => instance.getCoreRowModel().rowsById,\n    getColumnFilteredRows: () => instance.getColumnFilteredRowModel().rows,\n    getColumnFilteredFlatRows: () =>\n      instance.getColumnFilteredRowModel().flatRows,\n    getColumnFilteredRowsById: () =>\n      instance.getColumnFilteredRowModel().rowsById,\n\n    getGlobalFilteredRowModel: memo(\n      () => [\n        instance.getState().globalFilter,\n        instance.getColumnFilteredRowModel(),\n        instance.options.globalFilterRowsFn,\n      ],\n      (globalFilterValue, columnFilteredRowModel, globalFiltersFn) => {\n        const globalFilteredRowModel = (() => {\n          if (!globalFiltersFn || !globalFilterValue) {\n            return columnFilteredRowModel\n          }\n\n          if (process.env.NODE_ENV !== 'production' && instance.options.debug)\n            console.info('Global Filtering...')\n\n          return globalFiltersFn(\n            instance as ReactTable<any, any, any, any, any>,\n            globalFilterValue,\n            columnFilteredRowModel\n          )\n        })()\n\n        // Now that each filtered column has it's partially filtered rows,\n        // lets assign the final filtered rows to all of the other columns\n        const nonFilteredColumns = instance\n          .getAllLeafColumns()\n          .filter(\n            column =>\n              !instance.getState().columnFilters?.find(d => d.id === column.id)\n          )\n\n        // This essentially enables faceted filter options to be built easily\n        // using every column's preFilteredRows value\n\n        nonFilteredColumns.forEach(column => {\n          column.getPreFilteredRows = () => globalFilteredRowModel.rows\n        })\n\n        return globalFilteredRowModel\n      },\n      'getGlobalFilteredRowModel',\n      instance.options.debug\n    ),\n\n    getPreGlobalFilteredRows: () => instance.getColumnFilteredRowModel().rows,\n    getPreGlobalFilteredFlatRows: () =>\n      instance.getColumnFilteredRowModel().flatRows,\n    getPreGlobalFilteredRowsById: () =>\n      instance.getColumnFilteredRowModel().rowsById,\n    getGlobalFilteredRows: () => instance.getGlobalFilteredRowModel().rows,\n    getGlobalFilteredFlatRows: () =>\n      instance.getGlobalFilteredRowModel().flatRows,\n    getGlobalFilteredRowsById: () =>\n      instance.getGlobalFilteredRowModel().rowsById,\n  }\n}\n\nexport function shouldAutoRemoveFilter(\n  filterFn?: FilterFn<any, any, any, any, any>,\n  value?: any,\n  column?: Column<any, any, any, any, any>\n) {\n  return (\n    (filterFn && filterFn.autoRemove\n      ? filterFn.autoRemove(value, column)\n      : false) ||\n    typeof value === 'undefined' ||\n    (typeof value === 'string' && !value)\n  )\n}\n","import { Row } from './types'\n\nconst reSplitAlphaNumeric = /([0-9]+)/gm\n\nexport const sortTypes = {\n  alphanumeric,\n  alphanumericCaseSensitive,\n  text,\n  textCaseSensitive,\n  datetime,\n  basic,\n}\n\nexport type BuiltInSortType = keyof typeof sortTypes\n\nfunction alphanumeric<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>(\n  rowA: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  rowB: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  columnId: string\n) {\n  return compareAlphanumeric(\n    toString(rowA.values[columnId]).toLowerCase(),\n    toString(rowB.values[columnId]).toLowerCase()\n  )\n}\n\nfunction alphanumericCaseSensitive<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rowA: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  rowB: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  columnId: string\n) {\n  return compareAlphanumeric(\n    toString(rowA.values[columnId]),\n    toString(rowB.values[columnId])\n  )\n}\n\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr: string, bStr: string) {\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean)\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean)\n\n  // While\n  while (a.length && b.length) {\n    const aa = a.shift()!\n    const bb = b.shift()!\n\n    const an = parseInt(aa, 10)\n    const bn = parseInt(bb, 10)\n\n    const combo = [an, bn].sort()\n\n    // Both are string\n    if (isNaN(combo[0]!)) {\n      if (aa > bb) {\n        return 1\n      }\n      if (bb > aa) {\n        return -1\n      }\n      continue\n    }\n\n    // One is a string, one is a number\n    if (isNaN(combo[1]!)) {\n      return isNaN(an) ? -1 : 1\n    }\n\n    // Both are numbers\n    if (an > bn) {\n      return 1\n    }\n    if (bn > an) {\n      return -1\n    }\n  }\n\n  return a.length - b.length\n}\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nfunction text<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>(\n  rowA: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  rowB: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  columnId: string\n) {\n  return compareBasic(\n    toString(rowA.values[columnId]).toLowerCase(),\n    toString(rowB.values[columnId]).toLowerCase()\n  )\n}\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nfunction textCaseSensitive<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  rowA: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  rowB: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  columnId: string\n) {\n  return compareBasic(\n    toString(rowA.values[columnId]),\n    toString(rowB.values[columnId])\n  )\n}\n\nfunction datetime<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>(\n  rowA: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  rowB: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  columnId: string\n) {\n  return compareBasic(\n    (rowA.values[columnId] as Date).getTime(),\n    (rowB.values[columnId] as Date).getTime()\n  )\n}\n\nfunction basic<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>(\n  rowA: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  rowB: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  columnId: string\n) {\n  return compareBasic(rowA.values[columnId], rowB.values[columnId])\n}\n\n// Utils\n\nfunction compareBasic(a: any, b: any) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n\nfunction toString(a: any) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return ''\n    }\n    return String(a)\n  }\n  if (typeof a === 'string') {\n    return a\n  }\n  return ''\n}\n","import { MouseEvent, TouchEvent } from 'react'\nimport { RowModel } from '..'\nimport {\n  Getter,\n  OnChangeFn,\n  PropGetterValue,\n  ReactTable,\n  Row,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo, propGetter } from '../utils'\n\nexport type ExpandedStateList = Record<string, boolean>\nexport type ExpandedState = true | Record<string, boolean>\nexport type ExpandedTableState = {\n  expanded: ExpandedState\n}\n\nexport type ExpandedRow = {\n  toggleExpanded: (expanded?: boolean) => void\n  getIsExpanded: () => boolean\n  getCanExpand: () => boolean\n  getToggleExpandedProps: <TGetter extends Getter<ToggleExpandedProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleExpandedProps, TGetter>\n}\n\nexport type ExpandedOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  onExpandedChange?: OnChangeFn<ExpandedState>\n  autoResetExpanded?: boolean\n  enableExpanded?: boolean\n  expandRowsFn?: (\n    instance: ReactTable<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >,\n    expandedState: ExpandedState,\n    groupedRowModel: RowModel<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >\n  ) => RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  expandSubRows?: boolean\n  defaultCanExpand?: boolean\n  getIsRowExpanded?: (\n    row: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  ) => boolean\n  getRowCanExpand?: (\n    row: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  ) => boolean\n  paginateExpandedRows?: boolean\n}\n\nexport type ToggleExpandedProps = {\n  title?: string\n  onClick?: (event: MouseEvent | TouchEvent) => void\n}\n\nexport type ExpandedInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  setExpanded: (updater: Updater<ExpandedState>) => void\n  toggleRowExpanded: (rowId: string, expanded?: boolean) => void\n  toggleAllRowsExpanded: (expanded?: boolean) => void\n  resetExpanded: () => void\n  getRowCanExpand: (rowId: string) => boolean\n  getIsRowExpanded: (rowId: string) => boolean\n  getToggleExpandedProps: <TGetter extends Getter<ToggleExpandedProps>>(\n    rowId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleExpandedProps, TGetter>\n  getToggleAllRowsExpandedProps: <TGetter extends Getter<ToggleExpandedProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleExpandedProps, TGetter>\n  getIsAllRowsExpanded: () => boolean\n  getExpandedDepth: () => number\n  getExpandedRowModel: () => RowModel<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n  getPreExpandedRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getPreExpandedFlatRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getPreExpandedRowsById: () => Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n  getExpandedRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getExpandedFlatRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getExpandedRowsById: () => Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n}\n\n//\n\nexport function getInitialState(): ExpandedTableState {\n  return {\n    expanded: {},\n  }\n}\n\nexport function getDefaultOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): ExpandedOptions<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    onExpandedChange: makeStateUpdater('expanded', instance),\n    autoResetExpanded: true,\n    getIsRowExpanded: row => !!(row?.original as { expanded?: any }).expanded,\n    expandSubRows: true,\n    paginateExpandedRows: true,\n  }\n}\n\nexport function getInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): ExpandedInstance<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    setExpanded: updater =>\n      instance.options.onExpandedChange?.(\n        updater,\n        functionalUpdate(updater, instance.getState().expanded)\n      ),\n    toggleRowExpanded: (rowId, expanded) => {\n      if (!rowId) return\n\n      instance.setExpanded((old = {}) => {\n        const exists = old === true ? true : !!old?.[rowId]\n\n        let oldExpanded: ExpandedStateList = {}\n\n        if (old === true) {\n          Object.keys(instance.getRowsById()).forEach(rowId => {\n            oldExpanded[rowId] = true\n          })\n        } else {\n          oldExpanded = old\n        }\n\n        expanded = expanded ?? !exists\n\n        if (!exists && expanded) {\n          return {\n            ...oldExpanded,\n            [rowId]: true,\n          }\n        }\n\n        if (exists && !expanded) {\n          const { [rowId]: _, ...rest } = oldExpanded\n          return rest\n        }\n\n        return old\n      })\n    },\n    toggleAllRowsExpanded: expanded => {\n      if (expanded ?? !instance.getIsAllRowsExpanded()) {\n        instance.setExpanded(true)\n      } else {\n        instance.setExpanded({})\n      }\n    },\n    resetExpanded: () => {\n      instance.setExpanded(instance.options?.initialState?.expanded ?? {})\n    },\n    getIsRowExpanded: rowId => {\n      const row = instance.getRow(rowId)\n\n      if (!row) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `[ReactTable] getIsRowExpanded: no row found with id ${rowId}`\n          )\n        }\n        throw new Error()\n      }\n\n      const expanded = instance.getState().expanded\n\n      return !!(\n        instance.options.getIsRowExpanded?.(row) ??\n        (expanded || expanded?.[rowId])\n      )\n    },\n    getRowCanExpand: rowId => {\n      const row = instance.getRow(rowId)\n\n      if (!row) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `[ReactTable] getRowCanExpand: no row found with id ${rowId}`\n          )\n        }\n        throw new Error()\n      }\n\n      return (\n        instance.options.getRowCanExpand?.(row) ??\n        instance.options.enableExpanded ??\n        instance.options.defaultCanExpand ??\n        !!row.subRows?.length\n      )\n    },\n    getToggleExpandedProps: (rowId, userProps) => {\n      const row = instance.getRow(rowId)\n\n      if (!row) {\n        return\n      }\n\n      const canExpand = instance.getRowCanExpand(rowId)\n\n      const initialProps: ToggleExpandedProps = {\n        title: canExpand ? 'Toggle Expanded' : undefined,\n        onClick: canExpand\n          ? (e: MouseEvent | TouchEvent) => {\n              e.persist()\n              instance.toggleRowExpanded(rowId)\n            }\n          : undefined,\n      }\n\n      return propGetter(initialProps, userProps)\n    },\n    getToggleAllRowsExpandedProps: userProps => {\n      const initialProps: ToggleExpandedProps = {\n        title: 'Toggle All Expanded',\n        onClick: (e: MouseEvent | TouchEvent) => {\n          e.persist()\n          instance.toggleAllRowsExpanded()\n        },\n      }\n\n      return propGetter(initialProps, userProps)\n    },\n    getIsAllRowsExpanded: () => {\n      const expanded = instance.getState().expanded\n\n      // If expanded is true, save some cycles and return true\n      if (expanded === true) {\n        return true\n      }\n\n      // If any row is not expanded, return false\n      if (\n        Object.keys(instance.getRowsById()).some(\n          id => !instance.getIsRowExpanded(id)\n        )\n      ) {\n        return false\n      }\n\n      // They must all be expanded :shrug:\n      return true\n    },\n    getExpandedDepth: () => {\n      let maxDepth = 0\n\n      const rowIds =\n        instance.getState().expanded === true\n          ? Object.keys(instance.getRowsById())\n          : Object.keys(instance.getState().expanded)\n\n      rowIds.forEach(id => {\n        const splitId = id.split('.')\n        maxDepth = Math.max(maxDepth, splitId.length)\n      })\n\n      return maxDepth\n    },\n    getExpandedRowModel: memo(\n      () => [\n        instance.getState().expanded,\n        instance.getGroupedRowModel(),\n        instance.options.expandRowsFn,\n        instance.options.paginateExpandedRows,\n      ],\n      (expanded, rowModel, expandRowsFn, paginateExpandedRows) => {\n        if (\n          !expandRowsFn ||\n          // Do not expand if rows are not included in pagination\n          !paginateExpandedRows ||\n          !Object.keys(expanded ?? {}).length\n        ) {\n          return rowModel\n        }\n\n        if (process.env.NODE_ENV !== 'production' && instance.options.debug)\n          console.info('Expanding...')\n\n        return expandRowsFn(instance, expanded, rowModel)\n      },\n      'getExpandedRowModel',\n      instance.options.debug\n    ),\n\n    getPreExpandedRows: () => instance.getGroupedRowModel().rows,\n    getPreExpandedFlatRows: () => instance.getGroupedRowModel().flatRows,\n    getPreExpandedRowsById: () => instance.getGroupedRowModel().rowsById,\n    getExpandedRows: () => instance.getExpandedRowModel().rows,\n    getExpandedFlatRows: () => instance.getExpandedRowModel().flatRows,\n    getExpandedRowsById: () => instance.getExpandedRowModel().rowsById,\n  }\n}\n\nexport function createRow<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  row: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): ExpandedRow {\n  return {\n    toggleExpanded: expanded =>\n      void instance.toggleRowExpanded(row.id, expanded),\n    getIsExpanded: () => instance.getIsRowExpanded(row.id),\n    getCanExpand: () => row.subRows && !!row.subRows.length,\n    getToggleExpandedProps: userProps => {\n      const initialProps: ToggleExpandedProps = {\n        title: 'Toggle Row Expanded',\n        onClick: (e: MouseEvent | TouchEvent) => {\n          e.stopPropagation()\n          instance.toggleRowExpanded(row.id)\n        },\n      }\n      return propGetter(initialProps, userProps)\n    },\n  }\n}\n","import {\n  flattenBy,\n  functionalUpdate,\n  propGetter,\n  memo,\n  flexRender,\n  RequiredKeys,\n} from './utils'\n\nimport {\n  Updater,\n  PropGetterValue,\n  Options,\n  TableState,\n  ColumnDef,\n  Row,\n  Column,\n  Cell,\n  Header,\n  AccessorFn,\n  HeaderRenderProps,\n  TableProps,\n  TableBodyProps,\n  PropGetter,\n  Getter,\n  RowProps,\n  CellProps,\n  ReactTable,\n  RowValues,\n  Renderable,\n} from './types'\n\nimport * as Visibility from './features/Visibility'\nimport * as Ordering from './features/Ordering'\nimport * as Pinning from './features/Pinning'\nimport * as Headers from './features/Headers'\nimport * as Filters from './features/Filters'\nimport * as Sorting from './features/Sorting'\nimport * as Grouping from './features/Grouping'\nimport * as Expanding from './features/Expanding'\nimport { RowModel } from '.'\n\n// import './features/withColumnResizing';\n// import './features/withPagination';\n// import './features/withRowSelection';\n\nexport type CoreOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  data: TData[]\n  columns: ColumnDef<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  debug?: boolean\n  defaultColumn?: Partial<\n    ColumnDef<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n  initialState?: Partial<TableState>\n  state?: Partial<TableState>\n  getSubRows?: (originalRow: TData, index: number) => TData[]\n  getRowId?: (\n    originalRow: TData,\n    index: number,\n    parent?: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  ) => string\n  onStateChange?: (newState: TableState) => void\n}\n\nexport type TableCore<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> =\n  {\n    rerender: () => void\n    initialState: TableState\n    internalState: TableState\n    reset: () => void\n    options: RequiredKeys<\n      Options<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n      'state'\n    >\n    updateOptions: (\n      newOptions: Options<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      >\n    ) => void\n    getRowId: (\n      _: TData,\n      index: number,\n      parent?: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    ) => string\n    getState: () => TableState\n    setState: (updater: Updater<TableState>) => void\n    getDefaultColumn: () => Partial<\n      ColumnDef<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    >\n    getColumnDefs: () => ColumnDef<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[]\n    createColumn: (\n      columnDef: ColumnDef<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      >,\n      depth: number,\n      parent?: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    ) => Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    getAllColumns: () => Column<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[]\n    getAllFlatColumns: () => Column<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[]\n    getAllFlatColumnsById: () => Record<\n      string,\n      Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    >\n    getAllLeafColumns: () => Column<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[]\n    getColumn: (\n      columnId: string\n    ) => Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    getColumnWidth: (columnId: string) => number\n    getTotalWidth: () => number\n    createCell: (\n      row: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n      column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n      value: any\n    ) => Cell<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    createRow: (\n      id: string,\n      original: TData | undefined,\n      rowIndex: number,\n      depth: number,\n      values: Record<string, any>\n    ) => Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    getCoreRowModel: () => RowModel<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >\n    getCoreRows: () => Row<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[]\n    getCoreFlatRows: () => Row<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[]\n    getCoreRowsById: () => Record<\n      string,\n      Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    >\n    getRowModel: () => RowModel<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >\n    getRows: () => Row<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[]\n    getFlatRows: () => Row<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[]\n    getRowsById: () => Record<\n      string,\n      Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    >\n    getRow: (\n      id: string\n    ) => Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    getCell: (\n      rowId: string,\n      columnId: string\n    ) => Cell<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    getTableProps: PropGetter<TableProps>\n    getTableBodyProps: PropGetter<TableBodyProps>\n    getRowProps: <TGetter extends Getter<RowProps>>(\n      rowId: string,\n      userProps?: TGetter\n    ) => undefined | PropGetterValue<RowProps, TGetter>\n    getCellProps: <TGetter extends Getter<CellProps>>(\n      rowId: string,\n      columnId: string,\n      userProps?: TGetter\n    ) => undefined | PropGetterValue<CellProps, TGetter>\n  }\n\nexport type CoreRow<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> = {\n  id: string\n  index: number\n  original?: TData\n  depth: number\n  values: RowValues\n  leafRows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  subRows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  getRowProps: PropGetter<RowProps>\n  originalSubRows?: TData[]\n  getAllCells: () => Cell<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getAllCellsByColumnId: () => Record<\n    string,\n    Cell<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n}\n\nexport type CoreColumnDef<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = (\n  | {\n      accessorFn: AccessorFn<TData>\n      id: string\n      accessorKey?: never\n      header?:\n        | string\n        | Renderable<{\n            header: Header<\n              TData,\n              TValue,\n              TFilterFns,\n              TSortingFns,\n              TAggregationFns\n            >\n            column: Column<\n              TData,\n              TValue,\n              TFilterFns,\n              TSortingFns,\n              TAggregationFns\n            >\n          }>\n    }\n  | {\n      accessorKey: string & keyof TData\n      id?: string\n      accessorFn?: never\n      header?:\n        | string\n        | Renderable<{\n            header: Header<\n              TData,\n              TValue,\n              TFilterFns,\n              TSortingFns,\n              TAggregationFns\n            >\n            column: Column<\n              TData,\n              TValue,\n              TFilterFns,\n              TSortingFns,\n              TAggregationFns\n            >\n          }>\n    }\n  | {\n      id: string\n      accessorKey?: never\n      accessorFn?: never\n      header?:\n        | string\n        | Renderable<{\n            header: Header<\n              TData,\n              TValue,\n              TFilterFns,\n              TSortingFns,\n              TAggregationFns\n            >\n            column: Column<\n              TData,\n              TValue,\n              TFilterFns,\n              TSortingFns,\n              TAggregationFns\n            >\n          }>\n    }\n  | {\n      header: string\n      id?: string\n      accessorKey?: never\n      accessorFn?: never\n    }\n) & {\n  __generated: true\n  width?: number\n  minWidth?: number\n  maxWidth?: number\n  columns?: ColumnDef<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  footer?: Renderable<{\n    header: Header<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  }>\n  cell?: Renderable<{\n    column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    cell: Cell<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    value: TValue\n  }>\n  defaultIsVisible?: boolean\n}\n\nexport type CoreColumn<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  id: string\n  depth: number\n  accessorFn?: AccessorFn<TData>\n  columnDef: ColumnDef<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  getWidth: () => number\n  columns: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  parent?: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  getFlatColumns: () => Column<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getLeafColumns: () => Column<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n}\n\nexport function createTableInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  options: Options<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  rerender: () => void\n): ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  if (process.env.NODE_ENV !== 'production' && options.debug) {\n    console.info('Creating React Table Instance...')\n  }\n\n  let instance = {} as ReactTable<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n\n  const defaultOptions = {\n    ...Visibility.getDefaultOptions(instance),\n    ...Ordering.getDefaultOptions(instance),\n    ...Pinning.getDefaultOptions(instance),\n    ...Filters.getDefaultOptions(instance),\n    ...Sorting.getDefaultOptions(instance),\n    ...Grouping.getDefaultOptions(instance),\n    ...Expanding.getDefaultOptions(instance),\n  }\n\n  const defaultState = {}\n\n  const buildOptions = (\n    options: Options<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  ) => ({\n    state: defaultState,\n    ...defaultOptions,\n    ...options,\n  })\n\n  instance.options = buildOptions(options)\n\n  const initialState = {\n    ...Visibility.getInitialState(),\n    ...Ordering.getInitialState(),\n    ...Pinning.getInitialState(),\n    ...Filters.getInitialState(),\n    ...Sorting.getInitialState(),\n    ...Grouping.getInitialState(),\n    ...Expanding.getInitialState(),\n    ...(options.initialState ?? {}),\n  }\n\n  const finalInstance: ReactTable<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  > = {\n    ...instance,\n    ...Visibility.getInstance(instance),\n    ...Ordering.getInstance(instance),\n    ...Pinning.getInstance(instance),\n    ...Headers.getInstance(instance),\n    ...Filters.getInstance(instance),\n    ...Sorting.getInstance(instance),\n    ...Grouping.getInstance(instance),\n    ...Expanding.getInstance(instance),\n    rerender,\n    initialState,\n    internalState: initialState,\n    reset: () => {\n      instance.setState(instance.initialState)\n    },\n    updateOptions: newOptions => {\n      instance.options = buildOptions(newOptions)\n    },\n\n    getRowId: (\n      _: TData,\n      index: number,\n      parent?: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    ) => `${parent ? [parent.id, index].join('.') : index}`,\n\n    getState: () => {\n      return {\n        ...instance.internalState,\n        ...instance.options.state,\n      }\n    },\n\n    setState: (\n      updater: Updater<TableState>,\n      shouldRerender: boolean = true\n    ) => {\n      const newState = functionalUpdate(updater, instance.internalState)\n      const onStateChange = instance.options.onStateChange\n\n      instance.internalState = newState\n\n      if (onStateChange) {\n        onStateChange(newState)\n        return\n      }\n\n      if (shouldRerender) {\n        instance.rerender()\n      }\n    },\n\n    getDefaultColumn: memo(\n      () => [instance.options.defaultColumn],\n      defaultColumn => {\n        defaultColumn = (defaultColumn ?? {}) as Partial<\n          ColumnDef<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n        >\n\n        return {\n          header: (\n            props: HeaderRenderProps<\n              Header<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n            >\n          ) => props.header.column.id,\n          footer: (\n            props: HeaderRenderProps<\n              Header<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n            >\n          ) => props.header.column.id,\n          cell: ({ value = '' }: { value: any }): JSX.Element =>\n            typeof value === 'boolean' ? value.toString() : value,\n          ...Visibility.getDefaultColumn(),\n          ...Filters.getDefaultColumn(),\n          ...Sorting.getDefaultColumn(),\n          ...Grouping.getDefaultColumn(),\n          ...defaultColumn,\n        } as Partial<\n          ColumnDef<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n        >\n      },\n      'getDefaultColumn',\n      instance.options.debug\n    ),\n\n    getColumnDefs: () => instance.options.columns,\n\n    createColumn: (columnDef, depth: number, parent) => {\n      const defaultColumn = instance.getDefaultColumn()\n\n      let id =\n        columnDef.id ??\n        columnDef.accessorKey ??\n        (typeof columnDef.header === 'string' ? columnDef.header : undefined)\n\n      let accessorFn: AccessorFn<TData> | undefined\n\n      if (columnDef.accessorFn) {\n        accessorFn = columnDef.accessorFn\n      } else if (columnDef.accessorKey) {\n        accessorFn = (originalRow?: TData) =>\n          (originalRow as any)[columnDef.accessorKey]\n      }\n\n      if (!id) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            columnDef.accessorFn\n              ? `Columns require an id when using an accessorFn`\n              : `Columns require an id when using a non-string header`\n          )\n        }\n        throw new Error()\n      }\n\n      let column: CoreColumn<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      > = {\n        width: 150,\n        minWidth: 20,\n        maxWidth: Number.MAX_SAFE_INTEGER,\n        ...defaultColumn,\n        ...columnDef,\n        id: `${id}`,\n        accessorFn,\n        parent: parent as any,\n        depth,\n        columnDef,\n        columns: [],\n        getWidth: () => instance.getColumnWidth(column.id),\n        getFlatColumns: memo(\n          () => [true],\n          () => {\n            return [\n              column as Column<\n                TData,\n                TValue,\n                TFilterFns,\n                TSortingFns,\n                TAggregationFns\n              >,\n              ...column.columns?.flatMap(d => d.getFlatColumns()),\n            ]\n          },\n          'column.getFlatColumns',\n          instance.options.debug\n        ),\n        getLeafColumns: memo(\n          () => [instance.getOrderColumnsFn()],\n          orderColumns => {\n            if (column.columns?.length) {\n              let leafColumns = column.columns.flatMap(column =>\n                column.getLeafColumns()\n              )\n\n              return orderColumns(leafColumns)\n            }\n\n            return [\n              column as Column<\n                TData,\n                TValue,\n                TFilterFns,\n                TSortingFns,\n                TAggregationFns\n              >,\n            ]\n          },\n          'column.getLeafColumns',\n          instance.options.debug\n        ),\n      }\n\n      column = Object.assign(\n        column,\n        Visibility.createColumn(\n          column as Column<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >,\n          instance\n        ),\n        Pinning.createColumn(\n          column as Column<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >,\n          instance\n        ),\n        Filters.createColumn(\n          column as Column<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >,\n          instance\n        ),\n        Sorting.createColumn(\n          column as Column<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >,\n          instance\n        ),\n        Grouping.createColumn(\n          column as Column<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >,\n          instance\n        )\n      )\n\n      // Yes, we have to convert instance to uknown, because we know more than the compiler here.\n      return column as Column<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      >\n    },\n\n    getAllColumns: memo(\n      () => [instance.getColumnDefs()],\n      columnDefs => {\n        if (process.env.NODE_ENV !== 'production' && instance.options.debug)\n          console.info('Building Columns...')\n\n        const recurseColumns = (\n          columnDefs: ColumnDef<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >[],\n          parent?: Column<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >,\n          depth = 0\n        ): Column<\n          TData,\n          TValue,\n          TFilterFns,\n          TSortingFns,\n          TAggregationFns\n        >[] => {\n          return columnDefs.map(columnDef => {\n            const column = instance.createColumn(columnDef, depth, parent)\n\n            column.columns = columnDef.columns\n              ? recurseColumns(columnDef.columns, column, depth + 1)\n              : []\n\n            return column\n          })\n        }\n\n        return recurseColumns(columnDefs)\n      },\n      'getAllColumns',\n      instance.options.debug\n    ),\n\n    getAllFlatColumns: memo(\n      () => [instance.getAllColumns()],\n      allColumns => {\n        return allColumns.flatMap(column => {\n          return column.getFlatColumns()\n        })\n      },\n      'getAllFlatColumns',\n      instance.options.debug\n    ),\n\n    getAllFlatColumnsById: memo(\n      () => [instance.getAllFlatColumns()],\n      flatColumns => {\n        return flatColumns.reduce((acc, column) => {\n          acc[column.id] = column\n          return acc\n        }, {} as Record<string, Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>>)\n      },\n      'getAllFlatColumnsById',\n      instance.options.debug\n    ),\n\n    getAllLeafColumns: memo(\n      () => [instance.getAllColumns(), instance.getOrderColumnsFn()],\n      (allColumns, orderColumns) => {\n        let leafColumns = allColumns.flatMap(column => column.getLeafColumns())\n        return orderColumns(leafColumns)\n      },\n      'getAllLeafColumns',\n      instance.options.debug\n    ),\n\n    getColumn: columnId => {\n      const column = instance.getAllFlatColumnsById()[columnId]\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `[React Table] Column with id ${columnId} does not exist.`\n          )\n        }\n        throw new Error()\n      }\n\n      return column\n    },\n\n    getColumnWidth: (columnId: string) => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return Math.min(\n        Math.max(column.minWidth ?? 0, column.width ?? 0),\n        column.maxWidth ?? 0\n      )\n    },\n\n    createCell: (row, column, value) => {\n      const cell: Cell<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      > = {\n        id: `${row.id}_${column.id}`,\n        rowId: row.id,\n        columnId: column.id,\n        row,\n        column,\n        value,\n        getCellProps: userProps =>\n          instance.getCellProps(row.id, column.id, userProps)!,\n        renderCell: () => flexRender(column.cell, { column, cell, value }),\n      }\n\n      Object.assign(cell, {\n        ...Grouping.createCell(\n          cell as Cell<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          > &\n            Grouping.GroupingCell,\n          column,\n          row as Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n          instance\n        ),\n      })\n\n      return cell\n    },\n\n    createRow: (id, original, rowIndex, depth, values) => {\n      let row: CoreRow<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      > = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        values,\n        subRows: [],\n        leafRows: [],\n        getRowProps: userProps => instance.getRowProps(row.id, userProps)!,\n        getAllCells: undefined!,\n        getAllCellsByColumnId: undefined!,\n      }\n\n      row.getAllCells = memo(\n        () => [instance.getAllLeafColumns()],\n        leafColumns => {\n          return leafColumns.map(column => {\n            return instance.createCell(\n              row as Row<\n                TData,\n                TValue,\n                TFilterFns,\n                TSortingFns,\n                TAggregationFns\n              >,\n              column,\n              row.values[column.id]\n            )\n          })\n        },\n        process.env.NODE_ENV !== 'production' ? 'row.getAllCells' : '',\n        instance.options.debug\n      )\n\n      row.getAllCellsByColumnId = memo(\n        () => [row.getAllCells()],\n        allCells => {\n          return allCells.reduce((acc, cell) => {\n            acc[cell.columnId] = cell\n            return acc\n          }, {} as Record<string, Cell<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>>)\n        },\n        'row.getAllCellsByColumnId',\n        instance.options.debug\n      )\n\n      row = Object.assign(\n        row,\n        Headers.createRow(\n          row as Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n          instance\n        ),\n        Grouping.createRow(\n          row as Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n          instance\n        ),\n        Expanding.createRow(\n          row as Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n          instance\n        )\n      )\n\n      return row as Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    },\n\n    getCoreRowModel: memo(\n      () => [instance.options.data],\n      (\n        data\n      ): {\n        rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n        flatRows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n        rowsById: Record<\n          string,\n          Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n        >\n      } => {\n        if (process.env.NODE_ENV !== 'production' && instance.options.debug)\n          console.info('Accessing...')\n\n        // Auto-reset data-dependent states if configured\n        if (\n          instance.options.autoResetColumnFilters &&\n          // @ts-ignore\n          instance.getRowModelNonFirst\n        ) {\n          instance.resetColumnFilters()\n        }\n\n        if (\n          instance.options.autoResetGlobalFilter &&\n          // @ts-ignore\n          instance.getRowModelNonFirst\n        ) {\n          instance.resetGlobalFilter()\n        }\n\n        if (\n          instance.options.autoResetSorting &&\n          // @ts-ignore\n          instance.getRowModelNonFirst\n        ) {\n          instance.resetSorting()\n        }\n\n        if (\n          instance.options.autoResetGrouping &&\n          // @ts-ignore\n          instance.getRowModelNonFirst\n        ) {\n          instance.resetGrouping()\n        }\n\n        if (\n          instance.options.autoResetExpanded &&\n          // @ts-ignore\n          instance.getRowModelNonFirst\n        ) {\n          instance.resetExpanded()\n        }\n\n        // @ts-ignore\n        instance.getRowModelNonFirst = true\n\n        // Access the row model using initial columns\n        const rows: Row<\n          TData,\n          TValue,\n          TFilterFns,\n          TSortingFns,\n          TAggregationFns\n        >[] = []\n        const flatRows: Row<\n          TData,\n          TValue,\n          TFilterFns,\n          TSortingFns,\n          TAggregationFns\n        >[] = []\n        const rowsById: Record<\n          string,\n          Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n        > = {}\n\n        const leafColumns = instance.getAllLeafColumns()\n\n        const accessRow = (\n          originalRow: TData,\n          rowIndex: number,\n          depth = 0,\n          parentRows: Row<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >[],\n          parent?: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n        ) => {\n          const id = instance.getRowId(originalRow, rowIndex, parent)\n\n          if (!id) {\n            if (process.env.NODE_ENV !== 'production') {\n              throw new Error(`getRowId expected an ID, but got ${id}`)\n            }\n          }\n\n          const values: Record<string, any> = {}\n\n          for (let i = 0; i < leafColumns.length; i++) {\n            const column = leafColumns[i]\n            if (column && column.accessorFn) {\n              values[column.id] = column.accessorFn(originalRow, rowIndex)\n            }\n          }\n\n          // Make the row\n          const row = instance.createRow(\n            id,\n            originalRow,\n            rowIndex,\n            depth,\n            values\n          )\n\n          // Push instance row into the parentRows array\n          parentRows.push(row)\n          // Keep track of every row in a flat array\n          flatRows.push(row)\n          // Also keep track of every row by its ID\n          rowsById[id] = row\n\n          // Get the original subrows\n          if (instance.options.getSubRows) {\n            const originalSubRows = instance.options.getSubRows(\n              originalRow,\n              rowIndex\n            )\n\n            // Then recursively access them\n            if (originalSubRows?.length) {\n              row.originalSubRows = originalSubRows\n              const subRows: Row<\n                TData,\n                TValue,\n                TFilterFns,\n                TSortingFns,\n                TAggregationFns\n              >[] = []\n\n              for (let i = 0; i < row.originalSubRows.length; i++) {\n                accessRow(\n                  row.originalSubRows[i] as TData,\n                  i,\n                  depth + 1,\n                  subRows,\n                  row\n                )\n              }\n              // Keep the new subRows array on the row\n              row.subRows = subRows\n              row.leafRows = flattenBy(subRows, d => d.leafRows)\n            }\n          }\n        }\n\n        for (let i = 0; i < data.length; i++) {\n          accessRow(data[i] as TData, i, 0, rows)\n        }\n\n        return { rows, flatRows, rowsById }\n      },\n      'getRowModel',\n      instance.options.debug\n    ),\n\n    // The standard\n\n    getCoreRows: () => {\n      return instance.getCoreRowModel().rows\n    },\n\n    getCoreFlatRows: () => {\n      return instance.getCoreRowModel().flatRows\n    },\n\n    getCoreRowsById: () => {\n      return instance.getCoreRowModel().rowsById\n    },\n\n    // The final calls start at the bottom of the model,\n    // expanded rows, which then work their way up\n\n    getRowModel: () => {\n      return instance.getExpandedRowModel()\n    },\n\n    getRows: () => {\n      return instance.getRowModel().rows\n    },\n\n    getFlatRows: () => {\n      return instance.getRowModel().flatRows\n    },\n\n    getRowsById: () => {\n      return instance.getRowModel().rowsById\n    },\n\n    getRow: (id: string) => {\n      const row = instance.getRowsById()[id]\n\n      if (!row) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(`getRow expected an ID, but got ${id}`)\n        }\n        throw new Error()\n      }\n\n      return row\n    },\n\n    getCell: (rowId: string, columnId: string) => {\n      const row = instance.getRow(rowId)\n\n      if (!row) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(`[React Table] could not find row with id ${rowId}`)\n        }\n        throw new Error()\n      }\n\n      const cell = row.getAllCellsByColumnId()[columnId]\n\n      if (!cell) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            `[React Table] could not find cell ${columnId} in row ${rowId}`\n          )\n        }\n        throw new Error()\n      }\n\n      return cell\n    },\n\n    getTableProps: userProps => {\n      return propGetter(\n        {\n          role: 'table',\n        },\n        userProps\n      )\n    },\n\n    getTableBodyProps: userProps => {\n      return propGetter(\n        {\n          role: 'rowgroup',\n        },\n        userProps\n      )\n    },\n\n    getRowProps: (rowId, userProps) => {\n      const row = instance.getRow(rowId)\n      if (!row) {\n        return\n      }\n\n      return propGetter(\n        {\n          key: row.id,\n          role: 'row',\n        },\n        userProps\n      )\n    },\n\n    getCellProps: (rowId, columnId, userProps) => {\n      const cell = instance.getCell(rowId, columnId)\n\n      if (!cell) {\n        return\n      }\n\n      return propGetter(\n        {\n          key: cell.id,\n          role: 'gridcell',\n        },\n        userProps\n      )\n    },\n  }\n\n  return Object.assign(instance, finalInstance)\n}\n","import {\n  Cell,\n  Column,\n  Getter,\n  OnChangeFn,\n  PropGetterValue,\n  ReactTable,\n  Updater,\n} from '../types'\nimport { functionalUpdate, makeStateUpdater, memo, propGetter } from '../utils'\n\nexport type VisibilityOptions = {\n  onColumnVisibilityChange?: OnChangeFn<VisibilityState>\n  enableHiding?: boolean\n}\n\nexport type VisibilityDefaultOptions = {\n  onColumnVisibilityChange: OnChangeFn<VisibilityState>\n}\n\nexport type VisibilityState = Record<string, boolean>\n\nexport type VisibilityTableState = {\n  columnVisibility: VisibilityState\n}\n\nexport type VisibilityInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  getVisibleFlatColumns: () => Column<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getVisibleLeafColumns: () => Column<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  setColumnVisibility: (updater: Updater<VisibilityState>) => void\n  toggleColumnVisibility: (columnId: string, value?: boolean) => void\n  toggleAllColumnsVisible: (value?: boolean) => void\n  getColumnIsVisible: (columId: string) => boolean\n  getColumnCanHide: (columnId: string) => boolean\n  getIsAllColumnsVisible: () => boolean\n  getIsSomeColumnsVisible: () => boolean\n  getToggleAllColumnsVisibilityProps: <\n    TGetter extends Getter<ToggleAllColumnsVisibilityProps>\n  >(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleAllColumnsVisibilityProps, TGetter>\n}\n\ntype ToggleVisibilityProps = {}\ntype ToggleAllColumnsVisibilityProps = {}\n\nexport type VisibilityColumnDef = {\n  enableHiding?: boolean\n  defaultCanHide?: boolean\n}\n\nexport type VisibilityRow<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  getVisibleCells: () => Cell<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n}\n\nexport type VisibilityColumn = {\n  getCanHide: () => boolean\n  getIsVisible: () => boolean\n  toggleVisibility: (value?: boolean) => void\n  getToggleVisibilityProps: <TGetter extends Getter<ToggleVisibilityProps>>(\n    userProps?: TGetter\n  ) => PropGetterValue<ToggleVisibilityProps, TGetter>\n}\n\n//\n\nexport function getInitialState(): VisibilityTableState {\n  return {\n    columnVisibility: {},\n  }\n}\n\nexport function getDefaultOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): VisibilityDefaultOptions {\n  return {\n    onColumnVisibilityChange: makeStateUpdater('columnVisibility', instance),\n  }\n}\n\nexport function getDefaultColumn() {\n  return {\n    defaultIsVisible: true,\n  }\n}\n\nexport function createColumn<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): VisibilityColumn {\n  return {\n    getCanHide: () => instance.getColumnCanHide(column.id),\n    getIsVisible: () => instance.getColumnIsVisible(column.id),\n    toggleVisibility: value =>\n      instance.toggleColumnVisibility(column.id, value),\n    getToggleVisibilityProps: userProps => {\n      const props: ToggleVisibilityProps = {\n        type: 'checkbox',\n        checked: column.getIsVisible?.(),\n        title: 'Toggle Column Visibility',\n        onChange: (e: MouseEvent | TouchEvent) => {\n          column.toggleVisibility?.((e.target as HTMLInputElement).checked)\n        },\n      }\n\n      return propGetter(props, userProps)\n    },\n  }\n}\n\nexport function getInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): VisibilityInstance<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    getVisibleFlatColumns: memo(\n      () => [\n        instance.getAllFlatColumns(),\n        instance\n          .getAllFlatColumns()\n          .filter(d => d.getIsVisible?.())\n          .map(d => d.id)\n          .join('_'),\n      ],\n      allFlatColumns => {\n        return allFlatColumns.filter(d => d.getIsVisible?.())\n      },\n      'getVisibleFlatColumns',\n      instance.options.debug\n    ),\n\n    getVisibleLeafColumns: memo(\n      () => [\n        instance.getAllLeafColumns(),\n        instance\n          .getAllLeafColumns()\n          .filter(d => d.getIsVisible?.())\n          .map(d => d.id)\n          .join('_'),\n      ],\n      allFlatColumns => {\n        return allFlatColumns.filter(d => d.getIsVisible?.())\n      },\n      'getVisibleLeafColumns',\n      instance.options.debug\n    ),\n\n    setColumnVisibility: updater =>\n      instance.options.onColumnVisibilityChange?.(\n        updater,\n        functionalUpdate(updater, instance.getState().columnVisibility)\n      ),\n\n    toggleColumnVisibility: (columnId, value) => {\n      if (!columnId) return\n\n      if (instance.getColumnCanHide(columnId)) {\n        instance.setColumnVisibility(old => ({\n          ...old,\n          [columnId]: value ?? !instance.getColumnIsVisible(columnId),\n        }))\n      }\n    },\n\n    toggleAllColumnsVisible: value => {\n      value = value ?? !instance.getIsAllColumnsVisible()\n\n      instance.setColumnVisibility(\n        instance.getAllLeafColumns().reduce(\n          (obj, column) => ({\n            ...obj,\n            [column.id]: !value ? !column.getCanHide?.() : value,\n          }),\n          {}\n        )\n      )\n    },\n\n    getColumnIsVisible: columnId => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return (\n        instance.getState().columnVisibility?.[columnId] ??\n        column.defaultIsVisible ??\n        true\n      )\n    },\n\n    getColumnCanHide: columnId => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return (\n        instance.options.enableHiding ??\n        column.enableHiding ??\n        column.defaultCanHide ??\n        true\n      )\n    },\n\n    getIsAllColumnsVisible: () =>\n      !instance.getAllLeafColumns().some(column => !column.getIsVisible?.()),\n\n    getIsSomeColumnsVisible: () =>\n      instance.getAllLeafColumns().some(column => column.getIsVisible?.()),\n\n    getToggleAllColumnsVisibilityProps: userProps => {\n      const props: ToggleAllColumnsVisibilityProps = {\n        onChange: (e: MouseEvent) => {\n          instance.toggleAllColumnsVisible(\n            (e.target as HTMLInputElement)?.checked\n          )\n        },\n        type: 'checkbox',\n        title: 'Toggle visibility for all columns',\n        checked: instance.getIsAllColumnsVisible(),\n        indeterminate:\n          !instance.getIsAllColumnsVisible() &&\n          instance.getIsSomeColumnsVisible()\n            ? 'indeterminate'\n            : undefined,\n      }\n\n      return propGetter(props, userProps)\n    },\n  }\n}\n","import { OnChangeFn, Updater, ReactTable, Column } from '../types'\nimport { functionalUpdate, makeStateUpdater } from '../utils'\n\ntype ColumnPinningPosition = 'left' | 'right' | 'both'\n\nexport type ColumnPinningState = {\n  left?: string[]\n  right?: string[]\n}\n\nexport type ColumnPinningTableState = {\n  columnPinning: ColumnPinningState\n}\n\nexport type ColumnPinningOptions = {\n  onColumnPinningChange?: OnChangeFn<ColumnPinningState>\n  enablePinning?: boolean\n}\n\nexport type ColumnPinningDefaultOptions = {\n  onColumnPinningChange: OnChangeFn<ColumnPinningState>\n}\n\nexport type ColumnPinningColumnDef = {\n  enablePinning?: boolean\n  defaultCanPin?: boolean\n}\n\nexport type ColumnPinningColumn = {\n  getCanPin: () => boolean\n  getPinnedIndex: () => number\n  getIsPinned: () => false | ColumnPinningPosition\n  pin: (position: ColumnPinningPosition) => void\n}\n\nexport type ColumnPinningInstance<\n  _TData,\n  _TValue,\n  _TFilterFns,\n  _TSortingFns,\n  _TAggregationFns\n> = {\n  setColumnPinning: (updater: Updater<ColumnPinningState>) => void\n  resetColumnPinning: () => void\n  pinColumn: (columnId: string, position: ColumnPinningPosition) => void\n  getColumnCanPin: (columnId: string) => boolean\n  getColumnIsPinned: (columnId: string) => false | ColumnPinningPosition\n  getColumnPinnedIndex: (columnId: string) => number\n}\n\n//\n\nexport function getInitialState(): ColumnPinningTableState {\n  return {\n    columnPinning: {\n      left: [],\n      right: [],\n    },\n  }\n}\n\nexport function getDefaultOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): ColumnPinningDefaultOptions {\n  return {\n    onColumnPinningChange: makeStateUpdater('columnPinning', instance),\n  }\n}\n\nexport function createColumn<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): ColumnPinningColumn {\n  return {\n    getCanPin: () => instance.getColumnCanPin(column.id),\n    getPinnedIndex: () => instance.getColumnPinnedIndex(column.id),\n    getIsPinned: () => instance.getColumnIsPinned(column.id),\n    pin: position => instance.pinColumn(column.id, position),\n  }\n}\n\nexport function getInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): ColumnPinningInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> {\n  return {\n    setColumnPinning: updater =>\n      instance.options.onColumnPinningChange?.(\n        updater,\n        functionalUpdate(updater, instance.getState().columnPinning)\n      ),\n\n    resetColumnPinning: () =>\n      instance.setColumnPinning(\n        instance.options.initialState?.columnPinning ?? {}\n      ),\n\n    pinColumn: (columnId, position) => {\n      const column = instance.getColumn(columnId)\n\n      const columnIds = column\n        ?.getLeafColumns()\n        .map(d => d.id)\n        .filter(Boolean) as string[]\n\n      instance.setColumnPinning(old => {\n        if (position === 'right') {\n          return {\n            left: (old?.left ?? []).filter(d => !columnIds?.includes(d)),\n            right: [\n              ...(old?.right ?? []).filter(d => !columnIds?.includes(d)),\n              ...columnIds,\n            ],\n          }\n        }\n\n        if (position === 'left') {\n          return {\n            left: [\n              ...(old?.left ?? []).filter(d => !columnIds?.includes(d)),\n              ...columnIds,\n            ],\n            right: (old?.right ?? []).filter(d => !columnIds?.includes(d)),\n          }\n        }\n\n        return {\n          left: (old?.left ?? []).filter(d => !columnIds?.includes(d)),\n          right: (old?.right ?? []).filter(d => !columnIds?.includes(d)),\n        }\n      })\n    },\n\n    getColumnCanPin: columnId => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      const leafColumns = column.getLeafColumns()\n\n      return leafColumns.some(\n        d =>\n          d.enablePinning ??\n          instance.options.enablePinning ??\n          d.defaultCanPin ??\n          !!d.accessorFn\n      )\n    },\n\n    getColumnIsPinned: columnId => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      const leafColumnIds = column.getLeafColumns().map(d => d.id)\n\n      const { left, right } = instance.getState().columnPinning\n\n      const isLeft = leafColumnIds.some(d => left?.includes(d))\n      const isRight = leafColumnIds.some(d => right?.includes(d))\n\n      if (isLeft && isRight) {\n        return 'both'\n      }\n\n      return isLeft ? 'left' : isRight ? 'right' : false\n    },\n\n    getColumnPinnedIndex: columnId => {\n      const position = instance.getColumnIsPinned(columnId)\n\n      if (position === 'both') {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Column ${columnId} has leaf columns that are pinned on both sides`\n          )\n        }\n        throw new Error()\n      }\n\n      return position\n        ? instance.getState().columnPinning?.[position]?.indexOf(columnId) ?? -1\n        : 0\n    },\n  }\n}\n","import { MouseEvent, TouchEvent } from 'react'\nimport { RowModel } from '..'\nimport { BuiltInSortType, sortTypes } from '../sortTypes'\n\nimport {\n  Column,\n  Getter,\n  OnChangeFn,\n  PropGetterValue,\n  ReactTable,\n  Row,\n  Updater,\n} from '../types'\n\nimport {\n  functionalUpdate,\n  isFunction,\n  makeStateUpdater,\n  memo,\n  propGetter,\n} from '../utils'\n\nexport type ColumnSort = {\n  id: string\n  desc: boolean\n}\n\nexport type SortingState = ColumnSort[]\n\nexport type SortingFn<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> =\n  {\n    (\n      rowA: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n      rowB: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n      columnId: string\n    ): number\n  }\n\nexport type SortingTableState = {\n  sorting: SortingState\n}\n\nexport type SortType<TSortingFns> =\n  | 'auto'\n  | BuiltInSortType\n  | keyof TSortingFns\n  | SortingFn<any, any, any, TSortingFns, any>\n\nexport type SortingColumnDef<TFilterFns> = {\n  sortType?: SortType<TFilterFns>\n  sortDescFirst?: boolean\n  enableSorting?: boolean\n  enableMultiSort?: boolean\n  defaultCanSort?: boolean\n  invertSorting?: boolean\n  sortUndefined?: false | -1 | 1\n}\n\nexport type SortingColumn<\n  _TData,\n  _TValue,\n  TFilterFns,\n  _TSortingFns,\n  _TAggregationFns\n> = {\n  sortType: SortType<TFilterFns>\n  getCanSort: () => boolean\n  getCanMultiSort: () => boolean\n  getSortIndex: () => number\n  getIsSorted: () => false | 'asc' | 'desc'\n  toggleSorting: (desc?: boolean, isMulti?: boolean) => void\n  getToggleSortingProps: <TGetter extends Getter<ToggleSortingProps>>(\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleSortingProps, TGetter>\n}\n\nexport type SortingOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  sortTypes?: TSortingFns\n  onSortingChange?: OnChangeFn<SortingState>\n  autoResetSorting?: boolean\n  enableSorting?: boolean\n  enableSortingRemoval?: boolean\n  enableMultiRemove?: boolean\n  enableMultiSort?: boolean\n  sortDescFirst?: boolean\n  sortRowsFn?: (\n    instance: ReactTable<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >,\n    sortingState: SortingState,\n    globalFilteredRowModel: RowModel<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >\n  ) => RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  maxMultiSortColCount?: number\n  isMultiSortEvent?: (e: MouseEvent | TouchEvent) => boolean\n}\n\nexport type ToggleSortingProps = {\n  title?: string\n  onClick?: (event: MouseEvent | TouchEvent) => void\n}\n\nexport type SortingInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n> = {\n  getColumnAutoSortingFn: (\n    columnId: string\n  ) => SortingFn<any, any, any, any, any> | undefined\n\n  getColumnSortingFn: (\n    columnId: string\n  ) => SortingFn<any, any, any, any, any> | undefined\n\n  setSorting: (updater: Updater<SortingState>) => void\n  toggleColumnSorting: (\n    columnId: string,\n    desc?: boolean,\n    multi?: boolean\n  ) => void\n  resetSorting: () => void\n  getColumnCanSort: (columnId: string) => boolean\n  getColumnCanMultiSort: (columnId: string) => boolean\n  getColumnIsSorted: (columnId: string) => false | 'asc' | 'desc'\n  getColumnSortIndex: (columnId: string) => number\n  getToggleSortingProps: <TGetter extends Getter<ToggleSortingProps>>(\n    columnId: string,\n    userProps?: TGetter\n  ) => undefined | PropGetterValue<ToggleSortingProps, TGetter>\n  getSortedRowModel: () => RowModel<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n  getPreSortedRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getPreSortedFlatRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getPreSortedRowsById: () => Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n  getSortedRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getSortedFlatRows: () => Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[]\n  getSortedRowsById: () => Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  >\n}\n\n//\n\nexport function getDefaultColumn<TFilterFns>(): SortingColumnDef<TFilterFns> {\n  return {\n    sortType: 'auto',\n  }\n}\n\nexport function getInitialState(): SortingTableState {\n  return {\n    sorting: [],\n  }\n}\n\nexport function getDefaultOptions<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): SortingOptions<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    onSortingChange: makeStateUpdater('sorting', instance),\n    autoResetSorting: true,\n  }\n}\n\nexport function createColumn<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): SortingColumn<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    sortType: column.sortType,\n    getCanSort: () => instance.getColumnCanSort(column.id),\n    getCanMultiSort: () => instance.getColumnCanMultiSort(column.id),\n    getSortIndex: () => instance.getColumnSortIndex(column.id),\n    getIsSorted: () => instance.getColumnIsSorted(column.id),\n    toggleSorting: (desc, isMulti) =>\n      instance.toggleColumnSorting(column.id, desc, isMulti),\n    getToggleSortingProps: userProps =>\n      instance.getToggleSortingProps(column.id, userProps),\n  }\n}\n\nexport function getInstance<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): SortingInstance<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    getColumnAutoSortingFn: columnId => {\n      const firstRow = instance.getGlobalFilteredRowModel().flatRows[0]\n\n      const value = firstRow?.values[columnId]\n\n      if (typeof value === 'string') {\n        return sortTypes.alphanumeric\n      }\n\n      if (Object.prototype.toString.call(value) === '[object Date]') {\n        return sortTypes.datetime\n      }\n\n      return sortTypes.basic\n    },\n    getColumnSortingFn: columnId => {\n      const column = instance.getColumn(columnId)\n      const userSortTypes = instance.options.sortTypes\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return isFunction(column.sortType)\n        ? column.sortType\n        : column.sortType === 'auto'\n        ? instance.getColumnAutoFilterFn(columnId)\n        : (userSortTypes as Record<string, any>)?.[column.sortType as string] ??\n          (sortTypes[column.sortType as BuiltInSortType] as SortingFn<\n            TData,\n            TValue,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >)\n    },\n\n    setSorting: updater =>\n      instance.options.onSortingChange?.(\n        updater,\n        functionalUpdate(updater, instance.getState().sorting)\n      ),\n\n    toggleColumnSorting: (columnId, desc, multi) => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      instance.setSorting(old => {\n        // Find any existing sorting for this column\n        const existingSorting = old?.find(d => d.id === columnId)\n        const existingIndex = old?.findIndex(d => d.id === columnId)\n        const hasDescDefined = typeof desc !== 'undefined' && desc !== null\n\n        let newSorting: SortingState = []\n\n        // What should we do with this sort action?\n        let sortAction\n\n        if (!column.getCanMultiSort() && multi) {\n          if (existingSorting) {\n            sortAction = 'toggle'\n          } else {\n            sortAction = 'add'\n          }\n        } else {\n          // Normal mode\n          if (old?.length && existingIndex !== old.length - 1) {\n            sortAction = 'replace'\n          } else if (existingSorting) {\n            sortAction = 'toggle'\n          } else {\n            sortAction = 'replace'\n          }\n        }\n\n        const sortDescFirst =\n          column.sortDescFirst ?? instance.options.sortDescFirst\n\n        // Handle toggle states that will remove the sorting\n        if (\n          sortAction === 'toggle' && // Must be toggling\n          (instance.options.enableSortingRemoval ?? true) && // If enableSortRemove, enable in general\n          !hasDescDefined && // Must not be setting desc\n          (multi ? instance.options.enableMultiRemove ?? true : true) && // If multi, don't allow if enableMultiRemove\n          (existingSorting?.desc // Finally, detect if it should indeed be removed\n            ? !sortDescFirst\n            : sortDescFirst)\n        ) {\n          sortAction = 'remove'\n        }\n\n        if (sortAction === 'replace') {\n          newSorting = [\n            {\n              id: columnId,\n              desc: hasDescDefined ? desc! : !!sortDescFirst,\n            },\n          ]\n        } else if (sortAction === 'add' && old?.length) {\n          newSorting = [\n            ...old,\n            {\n              id: columnId,\n              desc: hasDescDefined ? desc! : !!sortDescFirst,\n            },\n          ]\n          // Take latest n columns\n          newSorting.splice(\n            0,\n            newSorting.length -\n              (instance.options.maxMultiSortColCount ?? Number.MAX_SAFE_INTEGER)\n          )\n        } else if (sortAction === 'toggle' && old?.length) {\n          // This flips (or sets) the\n          newSorting = old.map(d => {\n            if (d.id === columnId) {\n              return {\n                ...d,\n                desc: hasDescDefined ? desc! : !existingSorting?.desc,\n              }\n            }\n            return d\n          })\n        } else if (sortAction === 'remove' && old?.length) {\n          newSorting = old.filter(d => d.id !== columnId)\n        }\n\n        return newSorting\n      })\n    },\n\n    getColumnCanSort: columnId => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return (\n        column.enableSorting ??\n        instance.options.enableSorting ??\n        column.defaultCanSort ??\n        !!column.accessorFn\n      )\n    },\n\n    getColumnCanMultiSort: columnId => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      return (\n        column.enableMultiSort ??\n        instance.options.enableMultiSort ??\n        !!column.accessorFn\n      )\n    },\n\n    getColumnIsSorted: columnId => {\n      const columnSort = instance\n        .getState()\n        .sorting?.find(d => d.id === columnId)\n\n      return !columnSort ? false : columnSort.desc ? 'desc' : 'asc'\n    },\n\n    getColumnSortIndex: columnId =>\n      instance.getState().sorting?.findIndex(d => d.id === columnId) ?? -1,\n\n    resetSorting: () => {\n      instance.setSorting(instance.options?.initialState?.sorting ?? [])\n    },\n\n    getToggleSortingProps: (columnId, userProps) => {\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        throw new Error()\n      }\n\n      const canSort = column.getCanSort()\n\n      const initialProps: ToggleSortingProps = {\n        title: canSort ? 'Toggle Sorting' : undefined,\n        onClick: canSort\n          ? (e: MouseEvent | TouchEvent) => {\n              e.persist()\n              column.toggleSorting?.(\n                undefined,\n                column.getCanMultiSort()\n                  ? instance.options.isMultiSortEvent?.(e)\n                  : false\n              )\n            }\n          : undefined,\n      }\n\n      return propGetter(initialProps, userProps)\n    },\n\n    getSortedRowModel: memo(\n      () => [\n        instance.getState().sorting,\n        instance.getGlobalFilteredRowModel(),\n        instance.options.sortRowsFn,\n      ],\n      (sorting, rowModel, sortingFn) => {\n        if (!sortingFn || !sorting?.length) {\n          return rowModel\n        }\n\n        if (process.env.NODE_ENV !== 'production' && instance.options.debug)\n          console.info('Sorting...')\n\n        return sortingFn(instance, sorting, rowModel)\n      },\n      'getSortedRowModel',\n      instance.options.debug\n    ),\n\n    getPreSortedRows: () => instance.getGlobalFilteredRowModel().rows,\n    getPreSortedFlatRows: () => instance.getGlobalFilteredRowModel().flatRows,\n    getPreSortedRowsById: () => instance.getGlobalFilteredRowModel().rowsById,\n    getSortedRows: () => instance.getSortedRowModel().rows,\n    getSortedFlatRows: () => instance.getSortedRowModel().flatRows,\n    getSortedRowsById: () => instance.getSortedRowModel().rowsById,\n  }\n}\n","import { ReactTable, Row, RowModel } from '../types'\nimport { ColumnFiltersState } from '../features/Filters'\nimport { Options } from '..'\n\nexport const columnFilterRowsFn: Options<\n  any,\n  any,\n  {},\n  {},\n  {}\n>['columnFilterRowsFn'] = <\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  columnFilters: ColumnFiltersState,\n  rowModel: RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> => {\n  const newFilteredFlatRows: Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[] = []\n  const newFilteredRowsById: Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  > = {}\n\n  const filterFromChildrenUp = instance.options.filterFromChildrenUp\n\n  const filterRows = (\n    rowsToFilter: Row<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[],\n    depth: number\n  ) => {\n    columnFilters.forEach(({ id: columnId, value: filterValue }) => {\n      // Find the columnFilters column\n      const column = instance.getColumn(columnId)\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `React-Table: Could not find a column with id: ${columnId}`\n          )\n        }\n        throw new Error()\n      }\n\n      if (depth === 0) {\n        const preFilteredRows = [...rowsToFilter]\n        column.getPreFilteredRows = () => preFilteredRows\n      }\n\n      const filterFn = instance.getColumnFilterFn(column.id)\n\n      if (!filterFn) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Could not find a valid 'column.filterType' for column with the ID: ${column.id}.`\n          )\n        }\n        return\n      }\n\n      // Pass the rows, id, filterValue and column to the filterFn\n      // to get the filtered rows back\n      rowsToFilter = filterFn(rowsToFilter, [columnId], filterValue)\n    })\n\n    return rowsToFilter\n  }\n\n  if (filterFromChildrenUp) {\n    const recurseFilterRows = (\n      rowsToFilter: Row<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      >[],\n      depth = 0\n    ) => {\n      // Filter from children up\n      rowsToFilter = rowsToFilter.filter(row => {\n        if (!row.subRows?.length) {\n          return true\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n\n        return row.subRows.length\n      })\n\n      rowsToFilter = filterRows(rowsToFilter, depth)\n\n      // Apply the filter to any subRows\n      rowsToFilter.forEach(row => {\n        newFilteredFlatRows.push(row)\n        newFilteredRowsById[row.id] = row\n      })\n\n      return rowsToFilter\n    }\n\n    return {\n      rows: recurseFilterRows(rowModel.rows),\n      flatRows: newFilteredFlatRows,\n      rowsById: newFilteredRowsById,\n    }\n  }\n\n  // Filters top level and nested rows\n  const recurseFilterRows = (\n    rowsToFilter: Row<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[],\n    depth = 0\n  ) => {\n    // Filter from parents downward\n    rowsToFilter = filterRows(rowsToFilter, depth)\n\n    // Apply the filter to any subRows\n    // We technically could do this recursively in the above loop,\n    // but that would severely hinder the API for the user, since they\n    // would be required to do that recursion in some scenarios\n    rowsToFilter.forEach(row => {\n      newFilteredFlatRows.push(row)\n      newFilteredRowsById[row.id] = row\n\n      if (!filterFromChildrenUp) {\n        if (!row.subRows?.length) {\n          return\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n      }\n    })\n\n    return rowsToFilter\n  }\n\n  return {\n    rows: recurseFilterRows(rowModel.rows),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n","import * as React from 'react'\nimport { Cell, Column, Row } from '.'\nimport { createTableInstance } from './core'\nimport { ReactTable, ColumnDef, AccessorFn, Options } from './types'\nimport { Overwrite } from './utils'\n\ntype TableHelper<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> = {\n  RowType: <TTData>() => TableHelper<\n    TTData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n\n  FilterFns: <TTFilterFns>(\n    filterFns: TTFilterFns\n  ) => TableHelper<TData, TValue, TTFilterFns, TSortingFns, TAggregationFns>\n\n  SortingFns: <TTSortingFns>(\n    sortingFns: TTSortingFns\n  ) => TableHelper<TData, TValue, TFilterFns, TTSortingFns, TAggregationFns>\n\n  AggregationFns: <TTAggregationFns>(\n    aggregationFns: TTAggregationFns\n  ) => TableHelper<TData, TValue, TFilterFns, TSortingFns, TTAggregationFns>\n\n  createColumns: (\n    columns: ColumnDef<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[]\n  ) => ColumnDef<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n\n  createGroup: (\n    column: Overwrite<\n      ColumnDef<TData, unknown, TFilterFns, TSortingFns, TAggregationFns>,\n      { __generated?: never; accessorFn?: never; accessorKey?: never }\n    >\n  ) => ColumnDef<TData, unknown, TFilterFns, TSortingFns, TAggregationFns>\n\n  createColumn: <TAccessor extends AccessorFn<TData> | keyof TData>(\n    accessor: TAccessor,\n    column: TAccessor extends (...args: any[]) => any\n      ? // Accessor Fn\n        Overwrite<\n          ColumnDef<\n            TData,\n            ReturnType<TAccessor>,\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >,\n          {\n            __generated?: never\n            accessorFn?: never\n            accessorKey?: never\n            id: string\n          }\n        >\n      : TAccessor extends keyof TData\n      ? // Accessor Key\n        Overwrite<\n          ColumnDef<\n            TData,\n            TData[TAccessor],\n            TFilterFns,\n            TSortingFns,\n            TAggregationFns\n          >,\n          { __generated?: never; accessorFn?: never; accessorKey?: never }\n        >\n      : never\n  ) => ColumnDef<\n    TData,\n    TAccessor extends (...args: any[]) => any\n      ? ReturnType<TAccessor>\n      : TAccessor extends keyof TData\n      ? TData[TAccessor]\n      : never,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n\n  useTable: <TData, TValue, TFilterFns, TSortingFns, TAggregationFns>(\n    options: Options<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  ) => ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n\n  types: {\n    instance: ReactTable<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >\n    columnDef: ColumnDef<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >\n    column: Column<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    row: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    cell: Cell<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  }\n}\n\nexport function createTable<\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(): TableHelper<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> {\n  return {\n    RowType: () => createTable(),\n    FilterFns: () => createTable(),\n    SortingFns: () => createTable(),\n    AggregationFns: () => createTable(),\n    createColumns: columns => columns,\n    createColumn: (accessor, column) => {\n      column = {\n        ...column,\n        id: column.id,\n      }\n\n      if (typeof accessor === 'string') {\n        return {\n          ...column,\n          id: column.id ?? accessor,\n          accessorKey: accessor,\n          __generated: true,\n        }\n      }\n\n      if (typeof accessor === 'function') {\n        return {\n          ...column,\n          accessorFn: accessor,\n          __generated: true,\n        }\n      }\n\n      throw new Error('Invalid accessor')\n    },\n    createGroup: column => ({\n      ...column,\n      __generated: true,\n    }),\n    useTable: <TData, TValue, TFilterFns, TSortingFns, TAggregationFns>(\n      options: Options<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n    ): ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> => {\n      const instanceRef = React.useRef<\n        ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n      >(undefined!)\n\n      const rerender = React.useReducer(() => ({}), {})[1]\n\n      if (!instanceRef.current) {\n        instanceRef.current = createTableInstance<\n          TData,\n          TValue,\n          TFilterFns,\n          TSortingFns,\n          TAggregationFns\n        >(options, rerender)\n      }\n\n      instanceRef.current.updateOptions(options)\n\n      return instanceRef.current\n    },\n    types: undefined as any,\n  } as TableHelper<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n}\n","import { ReactTable, Row, RowModel } from '../types'\nimport { Options } from '../types'\nimport { ExpandedState } from '../features/Expanding'\n\nexport const expandRowsFn: Options<any, any, {}, {}, {}>['expandRowsFn'] = <\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  _expandedState: ExpandedState,\n  sortedRowModel: RowModel<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n): RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> => {\n  const expandedRows: Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[] = []\n\n  const { expandSubRows } = instance.options\n\n  const handleRow = (\n    row: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  ) => {\n    expandedRows.push(row)\n\n    if (\n      expandSubRows &&\n      row.subRows?.length &&\n      instance.getIsRowExpanded(row.id)\n    ) {\n      row.subRows.forEach(handleRow)\n    }\n  }\n\n  sortedRowModel.rows.forEach(handleRow)\n\n  return {\n    rows: expandedRows,\n    flatRows: sortedRowModel.flatRows,\n    rowsById: sortedRowModel.rowsById,\n  }\n}\n","import { Options } from '..'\nimport { ReactTable, Row, RowModel } from '../types'\n\nexport const globalFilterRowsFn: Options<\n  any,\n  any,\n  {},\n  {},\n  {}\n>['globalFilterRowsFn'] = <\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  globalFilter: any,\n  rowModel: RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> => {\n  const newFilteredFlatRows: Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[] = []\n  const newFilteredRowsById: Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  > = {}\n\n  const filterFromChildrenUp = instance.options.filterFromChildrenUp\n\n  const filterFn = instance.getGlobalFilterFn()\n\n  if (!filterFn) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`Could not find a valid 'globalFilterType'`)\n    }\n    return rowModel\n  }\n\n  const filterableColumns = instance\n    .getAllLeafColumns()\n    .filter(column => column.getCanGlobalFilter())\n\n  const filterableColumnIds = filterableColumns.map(d => d.id)\n\n  if (filterFromChildrenUp) {\n    const recurseFilterRows = (\n      rowsToFilter: Row<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      >[],\n      depth = 0\n    ) => {\n      // Filter from children up\n      rowsToFilter = rowsToFilter.filter(row => {\n        if (!row.subRows?.length) {\n          return true\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n\n        return row.subRows.length\n      })\n\n      rowsToFilter = filterFn(rowsToFilter, filterableColumnIds, globalFilter)\n\n      // Apply the filter to any subRows\n      rowsToFilter.forEach(row => {\n        newFilteredFlatRows.push(row)\n        newFilteredRowsById[row.id] = row\n      })\n\n      return rowsToFilter\n    }\n\n    return {\n      rows: recurseFilterRows(rowModel.rows),\n      flatRows: newFilteredFlatRows,\n      rowsById: newFilteredRowsById,\n    }\n  }\n\n  // Filters top level and nested rows\n  const recurseFilterRows = (\n    rowsToFilter: Row<\n      TData,\n      TValue,\n      TFilterFns,\n      TSortingFns,\n      TAggregationFns\n    >[],\n    depth = 0\n  ) => {\n    // Filter from parents downward\n    rowsToFilter = filterFn(rowsToFilter, filterableColumnIds, globalFilter)\n\n    // Apply the filter to any subRows\n    // We technically could do this recursively in the above loop,\n    // but that would severely hinder the API for the user, since they\n    // would be required to do that recursion in some scenarios\n    rowsToFilter.forEach(row => {\n      newFilteredFlatRows.push(row)\n      newFilteredRowsById[row.id] = row\n\n      if (!filterFromChildrenUp) {\n        if (!row.subRows?.length) {\n          return\n        }\n\n        row.subRows = recurseFilterRows(row.subRows, depth + 1)\n      }\n    })\n\n    return rowsToFilter\n  }\n\n  return {\n    rows: recurseFilterRows(rowModel.rows),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById,\n  }\n}\n","import { ReactTable, Row, RowModel } from '../types'\nimport { Options } from '../types'\nimport { GroupingState } from '../features/Grouping'\nimport { flattenBy } from '../utils'\n\nexport const groupRowsFn: Options<any, any, {}, {}, {}>['groupRowsFn'] = <\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  groupingState: GroupingState,\n  sortedRowModel: RowModel<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >\n): RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> => {\n  // Filter the grouping list down to columns that exist\n  const existingGrouping = groupingState.filter(columnId =>\n    instance.getColumn(columnId)\n  )\n\n  // Find the columns that can or are aggregating\n  // Uses each column to aggregate rows into a single value\n  const aggregateRowsToValues = (\n    leafRows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n    groupedRows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n    depth: number\n  ) => {\n    const values: Record<string, unknown> = {}\n\n    instance.getAllLeafColumns().forEach(column => {\n      // Don't aggregate columns that are in the grouping\n      if (existingGrouping.includes(column.id)) {\n        values[column.id] = groupedRows[0]\n          ? groupedRows[0].values[column.id]\n          : null\n        return\n      }\n\n      // Aggregate the values\n      const aggregateFn = instance.getColumnAggregationFn(column.id)\n\n      if (aggregateFn) {\n        // Get the columnValues to aggregate\n        const groupedValues = groupedRows.map(row => row.values[column.id])\n\n        // Get the columnValues to aggregate\n        const leafValues = leafRows.map(row => {\n          let columnValue = row.values[column.id]\n\n          if (!depth && column.aggregateValue) {\n            columnValue = column.aggregateValue(columnValue)\n          }\n\n          return columnValue\n        })\n\n        values[column.id] = aggregateFn(leafValues, groupedValues)\n      } else if (column.aggregationType) {\n        console.info({ column })\n        throw new Error(\n          process.env.NODE_ENV !== 'production'\n            ? `React Table: Invalid column.aggregateType option for column listed above`\n            : ''\n        )\n      } else {\n        values[column.id] = null\n      }\n    })\n\n    return values\n  }\n\n  const groupedFlatRows: Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[] = []\n  const groupedRowsById: Record<\n    string,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n  > = {}\n  // const onlyGroupedFlatRows: Row[] = [];\n  // const onlyGroupedRowsById: Record<RowId, Row> = {};\n  // const nonGroupedFlatRows: Row[] = [];\n  // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n  // Recursively group the data\n  const groupUpRecursively = (\n    rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n    depth = 0,\n    parentId: string\n  ) => {\n    // This is the last level, just return the rows\n    if (depth === existingGrouping.length) {\n      return rows\n    }\n\n    const columnId = existingGrouping[depth]!\n\n    // Group the rows together for this level\n    const rowGroupsMap = groupBy(rows, columnId)\n\n    // Peform aggregations for each group\n    const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map(\n      ([groupingValue, groupedRows], index) => {\n        let id = `${columnId}:${groupingValue}`\n        id = parentId ? `${parentId}>${id}` : id\n\n        // First, Recurse to group sub rows before aggregation\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id)\n\n        // Flatten the leaf rows of the rows in this group\n        const leafRows = depth\n          ? flattenBy(groupedRows, row => row.leafRows)\n          : groupedRows\n\n        const values = aggregateRowsToValues(leafRows, groupedRows, depth)\n\n        const row = instance.createRow(id, undefined, index, depth, values)\n\n        Object.assign(row, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n        })\n\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow)\n          groupedRowsById[subRow.id] = subRow\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        })\n\n        return row\n      }\n    )\n\n    return aggregatedGroupedRows\n  }\n\n  const groupedRows = groupUpRecursively(sortedRowModel.rows, 0, '')\n\n  groupedRows.forEach(subRow => {\n    groupedFlatRows.push(subRow)\n    groupedRowsById[subRow.id] = subRow\n    // if (subRow.getIsGrouped?.()) {\n    //   onlyGroupedFlatRows.push(subRow);\n    //   onlyGroupedRowsById[subRow.id] = subRow;\n    // } else {\n    //   nonGroupedFlatRows.push(subRow);\n    //   nonGroupedRowsById[subRow.id] = subRow;\n    // }\n  })\n\n  return {\n    rows: groupedRows,\n    flatRows: groupedFlatRows,\n    rowsById: groupedRowsById,\n  }\n}\n\nfunction groupBy<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>(\n  rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[],\n  columnId: string\n) {\n  const groupMap = new Map<\n    any,\n    Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  >()\n\n  return rows.reduce((map, row) => {\n    const resKey = `${row.values[columnId]}`\n    const previous = map.get(resKey)\n    if (!previous) {\n      map.set(resKey, [row])\n    } else {\n      map.set(resKey, [...previous, row])\n    }\n    return map\n  }, groupMap)\n}\n","import { ReactTable, Row, RowModel } from '../types'\nimport { SortingFn, SortingState } from '../features/Sorting'\nimport { Options } from '../types'\n\nexport const sortRowsFn: Options<any, any, {}, {}, {}>['sortRowsFn'] = <\n  TData,\n  TValue,\n  TFilterFns,\n  TSortingFns,\n  TAggregationFns\n>(\n  instance: ReactTable<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>,\n  sortingState: SortingState,\n  rowModel: RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>\n): RowModel<TData, TValue, TFilterFns, TSortingFns, TAggregationFns> => {\n  const sortedFlatRows: Row<\n    TData,\n    TValue,\n    TFilterFns,\n    TSortingFns,\n    TAggregationFns\n  >[] = []\n\n  // Filter out sortings that correspond to non existing columns\n  const availableSorting = sortingState.filter(sort =>\n    instance.getColumnCanSort(sort.id)\n  )\n\n  const columnInfoById: Record<\n    string,\n    {\n      sortUndefined?: false | -1 | 1\n      invertSorting?: boolean\n      sortingFn: SortingFn<\n        TData,\n        TValue,\n        TFilterFns,\n        TSortingFns,\n        TAggregationFns\n      >\n    }\n  > = {}\n\n  availableSorting.forEach(sortEntry => {\n    const column = instance.getColumn(sortEntry.id)!\n\n    columnInfoById[sortEntry.id] = {\n      sortUndefined: column.sortUndefined,\n      invertSorting: column.invertSorting,\n      sortingFn: instance.getColumnSortingFn(sortEntry.id)!,\n    }\n  })\n\n  const sortData = (\n    rows: Row<TData, TValue, TFilterFns, TSortingFns, TAggregationFns>[]\n  ) => {\n    // This will also perform a stable sorting using the row index\n    // if needed.\n    const sortedData = rows.slice()\n\n    sortedData.sort((rowA, rowB) => {\n      for (let i = 0; i < availableSorting.length; i += 1) {\n        const sortEntry = availableSorting[i]!\n        const columnInfo = columnInfoById[sortEntry.id]!\n        const isDesc = sortEntry?.desc ?? false\n\n        if (columnInfo.sortUndefined) {\n          const aValue = rowA.values[sortEntry.id]\n          const bValue = rowB.values[sortEntry.id]\n\n          const aUndefined = typeof aValue === 'undefined'\n          const bUndefined = typeof bValue === 'undefined'\n\n          if (aUndefined || bUndefined) {\n            return aUndefined && bUndefined ? 0 : aUndefined ? 1 : -1\n          }\n        }\n\n        // This function should always return in ascending order\n        let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id)\n\n        if (sortInt !== 0) {\n          if (isDesc) {\n            sortInt *= -1\n          }\n\n          if (columnInfo.invertSorting) {\n            sortInt *= -1\n          }\n\n          return sortInt\n        }\n      }\n\n      return rowA.index - rowB.index\n    })\n\n    // If there are sub-rows, sort them\n    sortedData.forEach(row => {\n      sortedFlatRows.push(row)\n      if (!row.subRows || row.subRows.length <= 1) {\n        return\n      }\n      row.subRows = sortData(row.subRows)\n    })\n\n    return sortedData\n  }\n\n  return {\n    rows: sortData(rowModel.rows),\n    flatRows: sortedFlatRows,\n    rowsById: rowModel.rowsById,\n  }\n}\n"],"names":["functionalUpdate","updater","input","makeStateUpdater","key","instance","setState","old","isFunction","d","Function","flattenBy","arr","getChildren","flat","recurse","subArr","forEach","item","push","children","length","document","React","useLayoutEffect","useEffect","propGetter","initial","getter","memo","getDeps","fn","debug","result","deps","newDeps","newSerializedDeps","oldSerializedDeps","some","dep","index","console","info","map","_","filter","Boolean","reduce","accu","curr","slice","parent","flexRender","Comp","props","component","proto","Object","getPrototypeOf","prototype","isReactComponent","isClassComponent","$$typeof","includes","description","isExoticComponent","aggregationTypes","sum","_leafValues","childValues","next","min","value","undefined","max","extent","mean","leafValues","count","median","values","Math","unique","Array","from","Set","uniqueCount","size","getInstance","setColumnOrder","options","onColumnOrderChange","getState","columnOrder","resetColumnOrder","initialState","getOrderColumnsFn","grouping","groupedColumnMode","columns","orderedColumns","columnOrderCopy","columnsCopy","targetColumnId","shift","foundIndex","findIndex","id","splice","leafColumns","nonGroupingColumns","col","groupingColumns","g","find","Grouping","buildHeaderGroups","allColumns","columnsToGroup","headerFamily","maxDepth","findMaxDepth","depth","column","getIsVisible","_column$columns","headerGroups","createHeaderGroup","headersToGroup","headerGroup","join","headers","getHeaderGroupProps","getterValue","getFooterGroupProps","parentHeaders","headerToGroup","latestParentHeader","reverse","isPlaceholder","header","createHeader","placeholderId","subHeaders","recurseHeadersForSpans","colSpan","rowSpan","childRowSpans","childColSpan","childRowSpan","_headerGroups$","filterTypes","includesString","includesStringSensitive","equalsString","equalsStringSensitive","arrIncludes","arrIncludesAll","equals","weakEquals","betweenNumberRange","rows","columnIds","filterValue","search","String","toLowerCase","row","rowValue","every","val","unsafeMin","unsafeMax","parsedMin","parseFloat","parsedMax","Number","isNaN","Infinity","temp","testFalsey","shouldAutoRemoveFilter","filterFn","autoRemove","reSplitAlphaNumeric","sortTypes","alphanumeric","rowA","rowB","columnId","compareAlphanumeric","toString","alphanumericCaseSensitive","text","compareBasic","textCaseSensitive","datetime","getTime","basic","aStr","bStr","a","split","b","aa","bb","an","parseInt","bn","combo","sort","setExpanded","onExpandedChange","expanded","toggleRowExpanded","rowId","exists","_old","oldExpanded","keys","getRowsById","toggleAllRowsExpanded","getIsAllRowsExpanded","resetExpanded","_instance$options","_instance$options$ini2","getIsRowExpanded","getRow","Error","getRowCanExpand","enableExpanded","defaultCanExpand","subRows","_row$subRows","getToggleExpandedProps","userProps","canExpand","title","onClick","e","persist","getToggleAllRowsExpandedProps","getExpandedDepth","splitId","getExpandedRowModel","getGroupedRowModel","expandRowsFn","paginateExpandedRows","rowModel","getPreExpandedRows","getPreExpandedFlatRows","flatRows","getPreExpandedRowsById","rowsById","getExpandedRows","getExpandedFlatRows","getExpandedRowsById","createTableInstance","rerender","defaultOptions","onColumnVisibilityChange","Visibility","Ordering","onColumnPinningChange","Pinning","onColumnFiltersChange","onGlobalFilterChange","autoResetColumnFilters","filterFromChildrenUp","autoResetGlobalFilter","globalFilterType","getColumnCanGlobalFilterFn","getCoreFlatRows","_instance$getCoreFlat","getAllCellsByColumnId","_instance$getCoreFlat2","Filters","onSortingChange","autoResetSorting","Sorting","onGroupingChange","autoResetGrouping","autoResetExpanded","original","expandSubRows","Expanding","defaultState","buildOptions","state","columnVisibility","columnPinning","left","right","columnFilters","globalFilter","sorting","finalInstance","getVisibleFlatColumns","getAllFlatColumns","allFlatColumns","getVisibleLeafColumns","getAllLeafColumns","setColumnVisibility","toggleColumnVisibility","getColumnCanHide","getColumnIsVisible","toggleAllColumnsVisible","getIsAllColumnsVisible","obj","getCanHide","getColumn","_instance$getState$co2","defaultIsVisible","enableHiding","defaultCanHide","getIsSomeColumnsVisible","getToggleAllColumnsVisibilityProps","onChange","target","_e$target","checked","type","indeterminate","setColumnPinning","resetColumnPinning","pinColumn","position","getLeafColumns","getColumnCanPin","enablePinning","defaultCanPin","accessorFn","getColumnIsPinned","leafColumnIds","isLeft","isRight","getColumnPinnedIndex","_instance$getState$co3","_instance$getState$co4","indexOf","getWidth","getLeafHeaders","leafHeaders","recurseHeader","h","getHeaderProps","getFooterProps","renderHeader","renderFooter","footer","getHeaderGroups","getAllColumns","leftColumns","rightColumns","centerColumns","getCenterHeaderGroups","getLeftHeaderGroups","getRightHeaderGroups","getFooterGroups","getLeftFooterGroups","getCenterFooterGroups","getRightFooterGroups","getFlatHeaders","getLeftFlatHeaders","getCenterFlatHeaders","getRightFlatHeaders","getCenterLeafHeaders","flatHeaders","_header$subHeaders","getLeftLeafHeaders","_header$subHeaders2","getRightLeafHeaders","_header$subHeaders3","center","_left$","_center$","_right$","getHeader","role","initialProps","getTotalWidth","width","Headers","getColumnAutoFilterFn","firstRow","isArray","getGlobalAutoFilterFn","getColumnFilterFn","userFilterTypes","filterType","getGlobalFilterFn","setColumnFilters","updateFn","_functionalUpdate","setGlobalFilter","resetGlobalFilter","getColumnCanColumnFilter","enableAllFilters","enableColumnFilter","enableFilters","enableColumnFilters","defaultCanFilter","defaultCanColumnFilter","getColumnCanGlobalFilter","enableGlobalFilter","defaultCanGlobalFilter","getColumnIsFiltered","getColumnFilterIndex","getColumnFilterValue","_instance$getState$co","setColumnFilterValue","previousfilter","newFilter","newFilterObj","resetColumnFilters","_instance$options2","_instance$options2$in","getColumnFilteredRowModel","getCoreRowModel","columnFilterRowsFn","columnFiltersFn","columnFilteredRowModel","_instance$getState$co5","getPreFilteredRows","getPreColumnFilteredRows","getPreColumnFilteredFlatRows","getPreColumnFilteredRowsById","getColumnFilteredRows","getColumnFilteredFlatRows","getColumnFilteredRowsById","getGlobalFilteredRowModel","globalFilterRowsFn","globalFilterValue","globalFiltersFn","globalFilteredRowModel","_instance$getState$co6","getPreGlobalFilteredRows","getPreGlobalFilteredFlatRows","getPreGlobalFilteredRowsById","getGlobalFilteredRows","getGlobalFilteredFlatRows","getGlobalFilteredRowsById","getColumnAutoSortingFn","call","getColumnSortingFn","userSortTypes","sortType","setSorting","toggleColumnSorting","desc","multi","sortAction","existingSorting","existingIndex","hasDescDefined","newSorting","getCanMultiSort","sortDescFirst","enableSortingRemoval","enableMultiRemove","maxMultiSortColCount","MAX_SAFE_INTEGER","getColumnCanSort","enableSorting","defaultCanSort","getColumnCanMultiSort","enableMultiSort","getColumnIsSorted","columnSort","_instance$getState$so","getColumnSortIndex","_instance$getState$so3","resetSorting","getToggleSortingProps","canSort","getCanSort","toggleSorting","isMultiSortEvent","getSortedRowModel","sortRowsFn","sortingFn","getPreSortedRows","getPreSortedFlatRows","getPreSortedRowsById","getSortedRows","getSortedFlatRows","getSortedRowsById","getColumnAutoAggregationFn","getColumnAggregationFn","userAggregationTypes","aggregationType","setGrouping","toggleColumnGrouping","getColumnCanGroup","enableGrouping","defaultCanGroup","getColumnIsGrouped","_instance$getState$gr","getColumnGroupedIndex","_instance$getState$gr2","resetGrouping","getToggleGroupingProps","canGroup","getCanGroup","toggleGrouping","getRowIsGrouped","_instance$getRow","groupingColumnId","groupRowsFn","getPreGroupedRows","getPreGroupedFlatRows","getPreGroupedRowsById","getGroupedRows","getGroupedFlatRows","getGroupedRowsById","internalState","reset","updateOptions","newOptions","getRowId","shouldRerender","newState","onStateChange","getDefaultColumn","defaultColumn","cell","getColumnDefs","createColumn","columnDef","accessorKey","originalRow","minWidth","maxWidth","getColumnWidth","getFlatColumns","flatMap","orderColumns","_column$columns2","assign","toggleVisibility","getToggleVisibilityProps","getCanPin","getPinnedIndex","getIsPinned","pin","getFacetInfo","preFilteredUniqueValues","Map","preFilteredMinMaxValues","_rows$","_rows$2","i","_rows$i","has","set","get","getCanColumnFilter","getCanGlobalFilter","getIsColumnFiltered","getPreFilteredUniqueValues","getPreFilteredMinMaxValues","getSortIndex","getIsSorted","isMulti","getGroupedIndex","getIsGrouped","columnDefs","recurseColumns","getAllFlatColumnsById","flatColumns","acc","createCell","getCellProps","renderCell","_instance","getIsPlaceholder","getIsAggregated","createRow","rowIndex","leafRows","getRowProps","getAllCells","allCells","_getAllVisibleCells","getVisibleCells","getLeftVisibleCells","getCenterVisibleCells","getRightVisibleCells","leftAndRight","toggleExpanded","getIsExpanded","getCanExpand","stopPropagation","data","getRowModelNonFirst","accessRow","parentRows","getSubRows","originalSubRows","getCoreRows","getCoreRowsById","getRowModel","getRows","getFlatRows","getCell","getTableProps","getTableBodyProps","newFilteredFlatRows","newFilteredRowsById","filterRows","rowsToFilter","preFilteredRows","recurseFilterRows","_row$subRows2","createTable","RowType","FilterFns","SortingFns","AggregationFns","createColumns","accessor","__generated","createGroup","useTable","instanceRef","useRef","useReducer","current","types","_expandedState","sortedRowModel","expandedRows","handleRow","filterableColumnIds","groupingState","existingGrouping","groupedFlatRows","groupedRowsById","groupedRows","groupUpRecursively","parentId","rowGroupsMap","groupMap","resKey","previous","groupBy","aggregatedGroupedRows","entries","groupingValue","aggregateFn","groupedValues","columnValue","aggregateValue","aggregateRowsToValues","subRow","sortingState","sortedFlatRows","availableSorting","columnInfoById","sortEntry","sortUndefined","invertSorting","sortData","sortedData","columnInfo","isDesc","aUndefined","bUndefined","sortInt"],"mappings":"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"}