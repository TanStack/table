import React from 'react';
import { Getter, NoInfer, PropGetterValue, Renderable } from './types';
export declare type IsAny<T> = 0 extends 1 & T ? true : false;
export declare type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export declare type RequiredKeys<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
export declare type Overwrite<T, U> = Omit<T, keyof U> & U;
export declare type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput;
export declare type Updater<TInput, TOutput> = TOutput | DataUpdateFunction<TInput, TOutput>;
export declare function functionalUpdate<TInput, TOutput = TInput>(updater: Updater<TInput, TOutput>, input: TInput): TOutput;
export declare function noop(): void;
export declare function makeStateUpdater(key: string, instance: unknown): (updater: Updater<any, any>) => void;
export declare const safeUseLayoutEffect: typeof React.useLayoutEffect;
export declare function useMountedLayoutEffect(fn: any, deps: any[]): void;
export declare function useGetLatest<T>(obj: T): () => T;
declare type AnyFunction = (...args: any) => any;
export declare function isFunction<T extends AnyFunction>(d: any): d is T;
export declare function flattenBy<TNode>(arr: TNode[], getChildren: (item: TNode) => TNode[]): TNode[];
declare type PropGetterImpl = <TBaseProps, TGetter extends Getter<TBaseProps>>(initial: TBaseProps, userProps?: TGetter) => PropGetterValue<TBaseProps, TGetter>;
export declare const propGetter: PropGetterImpl;
export declare function memo<TDeps extends readonly any[], TResult>(getDeps: () => [...TDeps], fn: (...args: NoInfer<[...TDeps]>) => TResult, key?: string, debug?: boolean): () => TResult;
export declare function isPlainObject(o: any): o is Object;
export declare type Render = typeof flexRender;
export declare function flexRender<TProps extends {}>(Comp: Renderable<TProps>, props: TProps): React.ReactNode;
export {};
