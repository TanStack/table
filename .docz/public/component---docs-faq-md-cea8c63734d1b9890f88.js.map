{"version":3,"sources":["webpack:///../docs/faq.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"mfAMO,IAAMA,EAAe,Q,6LAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,OADR,OAGA,oKACA,uBACA,iBAAQ,CACN,GAAM,8CADR,+CAGA,oJAAmI,0BAAYC,WAAW,KAAvB,YAAnI,mCAA2N,0BAAYA,WAAW,KAAvB,YAA3N,MAAsR,0BAAYA,WAAW,KAAvB,sBAAtR,+IACA,0DAAyC,0BAAYA,WAAW,KAAvB,aAAzC,6BACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,gSAgBL,8BACE,iBAAGA,WAAW,cAAa,sBAAQA,WAAW,KAAnB,2DAAmF,0BAAYA,WAAW,UAAvB,WAAnF,4HAAwQ,0BAAYA,WAAW,UAAvB,SAAxQ,gFAE7B,iBAAQ,CACN,GAAM,mDADR,oDAGA,4RAA2Q,0BAAYA,WAAW,KAAvB,mBAA3Q,gOACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,8WAiBL,2HACA,iBAAQ,CACN,GAAM,gDADR,iDAGA,+IAA8H,0BAAYA,WAAW,KAAvB,QAA9H,maAAklB,0BAAYA,WAAW,KAAvB,oBAAllB,6FACA,iHAAgG,0BAAYA,WAAW,KAAvB,UAAhG,wBAA2K,0BAAYA,WAAW,KAAvB,aAA3K,8BAA+P,0BAAYA,WAAW,KAAvB,KAA/P,sGAAmZ,0BAAYA,WAAW,KAAvB,oBAAnZ,oEACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,qrBAwBL,iBAAQ,CACN,GAAM,kFADR,mFAGA,oDAAmC,kBAAIA,WAAW,KAAf,UAAnC,uUACA,6NAA4M,0BAAYA,WAAW,KAAvB,SAA5M,6DACA,0IAAyH,0BAAYA,WAAW,KAAvB,QAAzH,wBACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,4rBA6BL,4G,oLAKJJ,EAAWK,gBAAiB","file":"component---docs-faq-md-cea8c63734d1b9890f88.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/jasonclark/Source/react-table/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"faq\"\n    }}>{`FAQ`}</h1>\n    <p>{`Below are some of the most frequently asked questions on how to use the React Table API to solve various table challenges you may encounter`}</p>\n    <hr />\n    <h2 {...{\n      \"id\": \"how-can-i-manually-control-the-table-state\"\n    }}>{`How can I manually control the table state?`}</h2>\n    <p>{`Occasionally, you may need to override some of the table state from a parent component or from somewhere above the usage of `}<inlineCode parentName=\"p\">{`useTable`}</inlineCode>{`. In this case, you can turn to `}<inlineCode parentName=\"p\">{`useTable`}</inlineCode>{`'s `}<inlineCode parentName=\"p\">{`useControlledState`}</inlineCode>{` option. This hook function is run on every render and allows you an opportunity to override or change the final table state in a safe way.`}</p>\n    <p>{`For example, to control a table's `}<inlineCode parentName=\"p\">{`pageIndex`}</inlineCode>{` from a parent component:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const [controlledPageIndex, setControlledPage] = React.useState(0)\n\nuseTable({\n  useControlledState: state => {\n    return React.useMemo(\n      () => ({\n        ...state,\n        pageIndex: controlledPageIndex,\n      }),\n      [state, controlledPageIndex]\n    )\n  },\n})\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\"><strong parentName=\"p\">{`It's important that the state override is done within a `}<inlineCode parentName=\"strong\">{`useMemo`}</inlineCode>{` call to prevent the state variable from changing on every render. It's also extremely important that you always use the `}<inlineCode parentName=\"strong\">{`state`}</inlineCode>{` in any dependencies to ensure that you do not block normal state updates.`}</strong></p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"how-can-i-use-the-table-state-to-fetch-new-data\"\n    }}>{`How can I use the table state to fetch new data?`}</h2>\n    <p>{`When managing your data externally or asynchronously (eg. server-side pagination/sorting/grouping/etc), you will need to fetch new data as the internal table state changes. With React Hooks, this is fantastically easier than it was before now that we have the `}<inlineCode parentName=\"p\">{`React.useEffect`}</inlineCode>{` hook. We can use this hook to \"watch\" the table state for specific changes and use those effects to trigger fetches for new data (or synchronize any other state you may be managing externally from your table component):`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function Table({ data, onFetchData }) {\n  const {\n    state: { pageIndex, pageSize, sortBy, filters },\n  } = useTable({\n    data,\n  })\n\n  // When these table states change, fetch new data!\n  React.useEffect(() => {\n    onFetchData({ pageIndex, pageSize, sortBy, filters })\n  }, [onFetchData, pageIndex, pageSize, sortBy, filters])\n\n  return </>\n}\n`}</code></pre>\n    <p>{`Using this approach, you can respond and trigger any type of side-effect using the table instance!`}</p>\n    <h2 {...{\n      \"id\": \"how-can-i-debounce-rapid-table-state-changes\"\n    }}>{`How can I debounce rapid table state changes?`}</h2>\n    <p>{`React Table has a few built-in side-effects of it's own (most of which are meant for resetting parts of the state when `}<inlineCode parentName=\"p\">{`data`}</inlineCode>{` changes). By default, these state side-effects are on and when their conditions are met, they immediately fire off actions that will manipulate the table state. Sometimes, this may result in multiple rapid rerenders (usually just 2, or one more than normal), and could cause any side-effects you have watching the table state to also fire multiple times in-a-row. To alleviate this edge-case, React Table exports a `}<inlineCode parentName=\"p\">{`useAsyncDebounce`}</inlineCode>{` function that will allow you to debounce rapid side-effects and only use the latest one.`}</p>\n    <p>{`A good example of this when doing server-side pagination and sorting, a user changes the `}<inlineCode parentName=\"p\">{`sortBy`}</inlineCode>{` for a table and the `}<inlineCode parentName=\"p\">{`pageIndex`}</inlineCode>{` is automatically reset to `}<inlineCode parentName=\"p\">{`0`}</inlineCode>{` via an internal side effect. This would normally cause our effect below to fire 2 times, but with `}<inlineCode parentName=\"p\">{`useAsyncDebounce`}</inlineCode>{` we can make sure our data fetch function only gets called once:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { useTable, useAsyncDebounce } from 'react-table'\n\nfunction Table({ data, onFetchData }) {\n  const {\n    state: { pageIndex, pageSize, sortBy, filters },\n  } = useTable({\n    data,\n  })\n\n  // Debounce our onFetchData call for 100ms\n  const onFetchDataDebounced = useAsyncDebounce(onFetchData, 100)\n\n  // When the these table states changes, fetch new data!\n  React.useEffect(() => {\n    // Every change will call our debounced function\n    onFetchDataDebounced({ pageIndex, pageSize, sortBy, filters })\n    // Only the last call after the 100ms debounce is over will be fired!\n  }, [onFetchDataDebounced, pageIndex, pageSize, sortBy, filters])\n\n  return </>\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"how-do-i-stop-my-table-state-from-automatically-resetting-when-my-data-changes\"\n    }}>{`How do I stop my table state from automatically resetting when my data changes?`}</h2>\n    <p>{`Most plugins use state that `}<em parentName=\"p\">{`should`}</em>{` normally reset when the data sources changes, but sometimes you need to suppress that from happening if you are filtering your data externally, or immutably editing your data while looking at it, or simply doing anything external with your data that you don't want to trigger a piece of table state to reset automatically.`}</p>\n    <p>{`For those situations, each plugin provides a way to disable the state from automatically resetting internally when data or other dependencies for a piece of state change. By setting any of them to `}<inlineCode parentName=\"p\">{`false`}</inlineCode>{`, you can stop the automatic resets from being triggered.`}</p>\n    <p>{`Here is an example of stopping basically every piece of state from changing as they normally do while we edit the `}<inlineCode parentName=\"p\">{`data`}</inlineCode>{` source for a table:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const [data, setData] = React.useState([])\nconst skipPageResetRef = React.useRef()\n\nconst updateData = newData => {\n  // When data gets updated with this function, set a flag\n  // to disable all of the auto resetting\n  skipPageResetRef.current = true\n\n  setData(newData)\n}\n\nReact.useEffect(() => {\n  // After the table has updated, always remove the flag\n  skipPageResetRef.current = false\n})\n\nuseTable({\n  ...\n  autoResetPage: !skipPageReset,\n  autoResetExpanded: !skipPageReset,\n  autoResetGroupBy: !skipPageReset,\n  autoResetSelectedRows: !skipPageReset,\n  autoResetSortBy: !skipPageReset,\n  autoResetFilters: !skipPageReset,\n  autoResetRowState: !skipPageReset,\n})\n`}</code></pre>\n    <p>{`Now, when we update our data, the above table states will not automatically reset!`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}